export {};

import * as React$1 from 'react';
import { GameObjects, Input, Scene as BaseScene, Tweens, Types } from 'phaser';

declare global {
namespace Gimloader {
namespace Stores {
enum RawFeatureType {
	Vertex = 0,
	Face = 1,
	Unknown = 2
}
enum RawJointAxis {
	LinX = 0,
	LinY = 1,
	AngX = 2
}
enum RawJointType {
	Revolute = 0,
	Fixed = 1,
	Prismatic = 2,
	Rope = 3,
	Spring = 4,
	Generic = 5
}
enum RawMotorModel {
	AccelerationBased = 0,
	ForceBased = 1
}
enum RawRigidBodyType {
	Dynamic = 0,
	Fixed = 1,
	KinematicPositionBased = 2,
	KinematicVelocityBased = 3
}
enum RawShapeType {
	Ball = 0,
	Cuboid = 1,
	Capsule = 2,
	Segment = 3,
	Polyline = 4,
	Triangle = 5,
	TriMesh = 6,
	HeightField = 7,
	Compound = 8,
	ConvexPolygon = 9,
	RoundCuboid = 10,
	RoundTriangle = 11,
	RoundConvexPolygon = 12,
	HalfSpace = 13,
	Voxels = 14
}
class RawBroadPhase {
	free(): void;
	constructor();
	castRay(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, rayOrig: RawVector, rayDir: RawVector, maxToi: number, solid: boolean, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): RawRayColliderHit | undefined;
	castRayAndGetNormal(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, rayOrig: RawVector, rayDir: RawVector, maxToi: number, solid: boolean, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): RawRayColliderIntersection | undefined;
	intersectionsWithRay(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, rayOrig: RawVector, rayDir: RawVector, maxToi: number, solid: boolean, callback: Function, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): void;
	intersectionWithShape(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, shapePos: RawVector, shapeRot: RawRotation, shape: RawShape, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): number | undefined;
	projectPoint(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, point: RawVector, solid: boolean, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): RawPointColliderProjection | undefined;
	projectPointAndGetFeature(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, point: RawVector, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): RawPointColliderProjection | undefined;
	intersectionsWithPoint(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, point: RawVector, callback: Function, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): void;
	castShape(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, shapePos: RawVector, shapeRot: RawRotation, shapeVel: RawVector, shape: RawShape, target_distance: number, maxToi: number, stop_at_penetration: boolean, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): RawColliderShapeCastHit | undefined;
	intersectionsWithShape(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, shapePos: RawVector, shapeRot: RawRotation, shape: RawShape, callback: Function, filter_flags: number, filter_groups: number | null | undefined, filter_exclude_collider: number | null | undefined, filter_exclude_rigid_body: number | null | undefined, filter_predicate: Function): void;
	collidersWithAabbIntersectingAabb(narrow_phase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, aabbCenter: RawVector, aabbHalfExtents: RawVector, callback: Function): void;
}
class RawCCDSolver {
	free(): void;
	constructor();
}
class RawColliderSet {
	free(): void;
	/**
	 * The world-space translation of this collider.
	 */
	coTranslation(handle: number): RawVector;
	/**
	 * The world-space orientation of this collider.
	 */
	coRotation(handle: number): RawRotation;
	/**
	 * The translation of this collider relative to its parent rigid-body.
	 *
	 * Returns the `None` if it doesn’t have a parent.
	 */
	coTranslationWrtParent(handle: number): RawVector | undefined;
	/**
	 * The orientation of this collider relative to its parent rigid-body.
	 *
	 * Returns the `None` if it doesn’t have a parent.
	 */
	coRotationWrtParent(handle: number): RawRotation | undefined;
	/**
	 * Sets the translation of this collider.
	 *
	 * # Parameters
	 * - `x`: the world-space position of the collider along the `x` axis.
	 * - `y`: the world-space position of the collider along the `y` axis.
	 * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it
	 * wasn't moving before modifying its position.
	 */
	coSetTranslation(handle: number, x: number, y: number): void;
	coSetTranslationWrtParent(handle: number, x: number, y: number): void;
	/**
	 * Sets the rotation angle of this collider.
	 *
	 * # Parameters
	 * - `angle`: the rotation angle, in radians.
	 * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it
	 * wasn't moving before modifying its position.
	 */
	coSetRotation(handle: number, angle: number): void;
	coSetRotationWrtParent(handle: number, angle: number): void;
	/**
	 * Is this collider a sensor?
	 */
	coIsSensor(handle: number): boolean;
	/**
	 * The type of the shape of this collider.
	 */
	coShapeType(handle: number): RawShapeType;
	coHalfspaceNormal(handle: number): RawVector | undefined;
	/**
	 * The half-extents of this collider if it is has a cuboid shape.
	 */
	coHalfExtents(handle: number): RawVector | undefined;
	/**
	 * Set the half-extents of this collider if it has a cuboid shape.
	 */
	coSetHalfExtents(handle: number, newHalfExtents: RawVector): void;
	/**
	 * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.
	 */
	coRadius(handle: number): number | undefined;
	/**
	 * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.
	 */
	coSetRadius(handle: number, newRadius: number): void;
	/**
	 * The half height of this collider if it is a capsule, cylinder, or cone shape.
	 */
	coHalfHeight(handle: number): number | undefined;
	/**
	 * Set the half height of this collider if it is a capsule, cylinder, or cone shape.
	 */
	coSetHalfHeight(handle: number, newHalfheight: number): void;
	/**
	 * The radius of the round edges of this collider.
	 */
	coRoundRadius(handle: number): number | undefined;
	/**
	 * Set the radius of the round edges of this collider.
	 */
	coSetRoundRadius(handle: number, newBorderRadius: number): void;
	coVoxelData(handle: number): Int32Array | undefined;
	coVoxelSize(handle: number): RawVector | undefined;
	coSetVoxel(handle: number, ix: number, iy: number, filled: boolean): void;
	coPropagateVoxelChange(handle1: number, handle2: number, ix: number, iy: number, shift_x: number, shift_y: number): void;
	coCombineVoxelStates(handle1: number, handle2: number, shift_x: number, shift_y: number): void;
	/**
	 * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.
	 */
	coVertices(handle: number): Float32Array | undefined;
	/**
	 * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.
	 */
	coIndices(handle: number): Uint32Array | undefined;
	coTriMeshFlags(handle: number): number | undefined;
	/**
	 * The height of this heightfield if it is one.
	 */
	coHeightfieldHeights(handle: number): Float32Array | undefined;
	/**
	 * The scaling factor applied of this heightfield if it is one.
	 */
	coHeightfieldScale(handle: number): RawVector | undefined;
	/**
	 * The unique integer identifier of the collider this collider is attached to.
	 */
	coParent(handle: number): number | undefined;
	coSetEnabled(handle: number, enabled: boolean): void;
	coIsEnabled(handle: number): boolean;
	coSetContactSkin(handle: number, contact_skin: number): void;
	coContactSkin(handle: number): number;
	/**
	 * The friction coefficient of this collider.
	 */
	coFriction(handle: number): number;
	/**
	 * The restitution coefficient of this collider.
	 */
	coRestitution(handle: number): number;
	/**
	 * The density of this collider.
	 */
	coDensity(handle: number): number;
	/**
	 * The mass of this collider.
	 */
	coMass(handle: number): number;
	/**
	 * The volume of this collider.
	 */
	coVolume(handle: number): number;
	/**
	 * The collision groups of this collider.
	 */
	coCollisionGroups(handle: number): number;
	/**
	 * The solver groups of this collider.
	 */
	coSolverGroups(handle: number): number;
	/**
	 * The physics hooks enabled for this collider.
	 */
	coActiveHooks(handle: number): number;
	/**
	 * The collision types enabled for this collider.
	 */
	coActiveCollisionTypes(handle: number): number;
	/**
	 * The events enabled for this collider.
	 */
	coActiveEvents(handle: number): number;
	/**
	 * The total force magnitude beyond which a contact force event can be emitted.
	 */
	coContactForceEventThreshold(handle: number): number;
	coContainsPoint(handle: number, point: RawVector): boolean;
	coCastShape(handle: number, colliderVel: RawVector, shape2: RawShape, shape2Pos: RawVector, shape2Rot: RawRotation, shape2Vel: RawVector, target_distance: number, maxToi: number, stop_at_penetration: boolean): RawShapeCastHit | undefined;
	coCastCollider(handle: number, collider1Vel: RawVector, collider2handle: number, collider2Vel: RawVector, target_distance: number, max_toi: number, stop_at_penetration: boolean): RawColliderShapeCastHit | undefined;
	coIntersectsShape(handle: number, shape2: RawShape, shapePos2: RawVector, shapeRot2: RawRotation): boolean;
	coContactShape(handle: number, shape2: RawShape, shapePos2: RawVector, shapeRot2: RawRotation, prediction: number): RawShapeContact | undefined;
	coContactCollider(handle: number, collider2handle: number, prediction: number): RawShapeContact | undefined;
	coProjectPoint(handle: number, point: RawVector, solid: boolean): RawPointProjection;
	coIntersectsRay(handle: number, rayOrig: RawVector, rayDir: RawVector, maxToi: number): boolean;
	coCastRay(handle: number, rayOrig: RawVector, rayDir: RawVector, maxToi: number, solid: boolean): number;
	coCastRayAndGetNormal(handle: number, rayOrig: RawVector, rayDir: RawVector, maxToi: number, solid: boolean): RawRayIntersection | undefined;
	coSetSensor(handle: number, is_sensor: boolean): void;
	coSetRestitution(handle: number, restitution: number): void;
	coSetFriction(handle: number, friction: number): void;
	coFrictionCombineRule(handle: number): number;
	coSetFrictionCombineRule(handle: number, rule: number): void;
	coRestitutionCombineRule(handle: number): number;
	coSetRestitutionCombineRule(handle: number, rule: number): void;
	coSetCollisionGroups(handle: number, groups: number): void;
	coSetSolverGroups(handle: number, groups: number): void;
	coSetActiveHooks(handle: number, hooks: number): void;
	coSetActiveEvents(handle: number, events: number): void;
	coSetActiveCollisionTypes(handle: number, types: number): void;
	coSetShape(handle: number, shape: RawShape): void;
	coSetContactForceEventThreshold(handle: number, threshold: number): void;
	coSetDensity(handle: number, density: number): void;
	coSetMass(handle: number, mass: number): void;
	coSetMassProperties(handle: number, mass: number, centerOfMass: RawVector, principalAngularInertia: number): void;
	constructor();
	len(): number;
	contains(handle: number): boolean;
	createCollider(enabled: boolean, shape: RawShape, translation: RawVector, rotation: RawRotation, massPropsMode: number, mass: number, centerOfMass: RawVector, principalAngularInertia: number, density: number, friction: number, restitution: number, frictionCombineRule: number, restitutionCombineRule: number, isSensor: boolean, collisionGroups: number, solverGroups: number, activeCollisionTypes: number, activeHooks: number, activeEvents: number, contactForceEventThreshold: number, contactSkin: number, hasParent: boolean, parent: number, bodies: RawRigidBodySet): number | undefined;
	/**
	 * Removes a collider from this set and wake-up the rigid-body it is attached to.
	 */
	remove(handle: number, islands: RawIslandManager, bodies: RawRigidBodySet, wakeUp: boolean): void;
	/**
	 * Checks if a collider with the given integer handle exists.
	 */
	isHandleValid(handle: number): boolean;
	/**
	 * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.
	 *
	 * # Parameters
	 * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.
	 */
	forEachColliderHandle(f: Function): void;
}
class RawColliderShapeCastHit {
	private constructor();
	free(): void;
	colliderHandle(): number;
	time_of_impact(): number;
	witness1(): RawVector;
	witness2(): RawVector;
	normal1(): RawVector;
	normal2(): RawVector;
}
class RawContactForceEvent {
	private constructor();
	free(): void;
	/**
	 * The first collider involved in the contact.
	 */
	collider1(): number;
	/**
	 * The second collider involved in the contact.
	 */
	collider2(): number;
	/**
	 * The sum of all the forces between the two colliders.
	 */
	total_force(): RawVector;
	/**
	 * The sum of the magnitudes of each force between the two colliders.
	 *
	 * Note that this is **not** the same as the magnitude of `self.total_force`.
	 * Here we are summing the magnitude of all the forces, instead of taking
	 * the magnitude of their sum.
	 */
	total_force_magnitude(): number;
	/**
	 * The world-space (unit) direction of the force with strongest magnitude.
	 */
	max_force_direction(): RawVector;
	/**
	 * The magnitude of the largest force at a contact point of this contact pair.
	 */
	max_force_magnitude(): number;
}
class RawContactManifold {
	private constructor();
	free(): void;
	normal(): RawVector;
	local_n1(): RawVector;
	local_n2(): RawVector;
	subshape1(): number;
	subshape2(): number;
	num_contacts(): number;
	contact_local_p1(i: number): RawVector | undefined;
	contact_local_p2(i: number): RawVector | undefined;
	contact_dist(i: number): number;
	contact_fid1(i: number): number;
	contact_fid2(i: number): number;
	contact_impulse(i: number): number;
	contact_tangent_impulse(i: number): number;
	num_solver_contacts(): number;
	solver_contact_point(i: number): RawVector | undefined;
	solver_contact_dist(i: number): number;
	solver_contact_friction(i: number): number;
	solver_contact_restitution(i: number): number;
	solver_contact_tangent_velocity(i: number): RawVector;
}
class RawContactPair {
	private constructor();
	free(): void;
	collider1(): number;
	collider2(): number;
	numContactManifolds(): number;
	contactManifold(i: number): RawContactManifold | undefined;
}
class RawDebugRenderPipeline {
	free(): void;
	constructor();
	vertices(): Float32Array;
	colors(): Float32Array;
	render(bodies: RawRigidBodySet, colliders: RawColliderSet, impulse_joints: RawImpulseJointSet, multibody_joints: RawMultibodyJointSet, narrow_phase: RawNarrowPhase, filter_flags: number, filter_predicate: Function): void;
}
class RawDeserializedWorld {
	private constructor();
	free(): void;
	takeGravity(): RawVector | undefined;
	takeIntegrationParameters(): RawIntegrationParameters | undefined;
	takeIslandManager(): RawIslandManager | undefined;
	takeBroadPhase(): RawBroadPhase | undefined;
	takeNarrowPhase(): RawNarrowPhase | undefined;
	takeBodies(): RawRigidBodySet | undefined;
	takeColliders(): RawColliderSet | undefined;
	takeImpulseJoints(): RawImpulseJointSet | undefined;
	takeMultibodyJoints(): RawMultibodyJointSet | undefined;
}
class RawEventQueue {
	free(): void;
	/**
	 * Creates a new event collector.
	 *
	 * # Parameters
	 * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will
	 * be automatically drained before each `world.step(collector)`. If false, the collector will
	 * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of
	 * RAM if no drain is performed.
	 */
	constructor(autoDrain: boolean);
	/**
	 * Applies the given javascript closure on each collision event of this collector, then clear
	 * the internal collision event buffer.
	 *
	 * # Parameters
	 * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The
	 * closure should take three arguments: two integers representing the handles of the colliders
	 * involved in the collision, and a boolean indicating if the collision started (true) or stopped
	 * (false).
	 */
	drainCollisionEvents(f: Function): void;
	drainContactForceEvents(f: Function): void;
	/**
	 * Removes all events contained by this collector.
	 */
	clear(): void;
}
class RawGenericJoint {
	private constructor();
	free(): void;
	static spring(rest_length: number, stiffness: number, damping: number, anchor1: RawVector, anchor2: RawVector): RawGenericJoint;
	static rope(length: number, anchor1: RawVector, anchor2: RawVector): RawGenericJoint;
	/**
	 * Creates a new joint descriptor that builds a Prismatic joint.
	 *
	 * A prismatic joint removes all the degrees of freedom between the
	 * affected bodies, except for the translation along one axis.
	 *
	 * Returns `None` if any of the provided axes cannot be normalized.
	 */
	static prismatic(anchor1: RawVector, anchor2: RawVector, axis: RawVector, limitsEnabled: boolean, limitsMin: number, limitsMax: number): RawGenericJoint | undefined;
	/**
	 * Creates a new joint descriptor that builds a Fixed joint.
	 *
	 * A fixed joint removes all the degrees of freedom between the affected bodies.
	 */
	static fixed(anchor1: RawVector, axes1: RawRotation, anchor2: RawVector, axes2: RawRotation): RawGenericJoint;
	/**
	 * Create a new joint descriptor that builds Revolute joints.
	 *
	 * A revolute joint removes all degrees of freedom between the affected
	 * bodies except for the rotation.
	 */
	static revolute(anchor1: RawVector, anchor2: RawVector): RawGenericJoint | undefined;
}
class RawImpulseJointSet {
	free(): void;
	/**
	 * The type of this joint.
	 */
	jointType(handle: number): RawJointType;
	/**
	 * The unique integer identifier of the first rigid-body this joint it attached to.
	 */
	jointBodyHandle1(handle: number): number;
	/**
	 * The unique integer identifier of the second rigid-body this joint is attached to.
	 */
	jointBodyHandle2(handle: number): number;
	/**
	 * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.
	 */
	jointFrameX1(handle: number): RawRotation;
	/**
	 * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.
	 */
	jointFrameX2(handle: number): RawRotation;
	/**
	 * The position of the first anchor of this joint.
	 *
	 * The first anchor gives the position of the points application point on the
	 * local frame of the first rigid-body it is attached to.
	 */
	jointAnchor1(handle: number): RawVector;
	/**
	 * The position of the second anchor of this joint.
	 *
	 * The second anchor gives the position of the points application point on the
	 * local frame of the second rigid-body it is attached to.
	 */
	jointAnchor2(handle: number): RawVector;
	/**
	 * Sets the position of the first local anchor
	 */
	jointSetAnchor1(handle: number, newPos: RawVector): void;
	/**
	 * Sets the position of the second local anchor
	 */
	jointSetAnchor2(handle: number, newPos: RawVector): void;
	/**
	 * Are contacts between the rigid-bodies attached by this joint enabled?
	 */
	jointContactsEnabled(handle: number): boolean;
	/**
	 * Sets whether contacts are enabled between the rigid-bodies attached by this joint.
	 */
	jointSetContactsEnabled(handle: number, enabled: boolean): void;
	/**
	 * Are the limits for this joint enabled?
	 */
	jointLimitsEnabled(handle: number, axis: RawJointAxis): boolean;
	/**
	 * Return the lower limit along the given joint axis.
	 */
	jointLimitsMin(handle: number, axis: RawJointAxis): number;
	/**
	 * If this is a prismatic joint, returns its upper limit.
	 */
	jointLimitsMax(handle: number, axis: RawJointAxis): number;
	/**
	 * Enables and sets the joint limits
	 */
	jointSetLimits(handle: number, axis: RawJointAxis, min: number, max: number): void;
	jointConfigureMotorModel(handle: number, axis: RawJointAxis, model: RawMotorModel): void;
	jointConfigureMotorVelocity(handle: number, axis: RawJointAxis, targetVel: number, factor: number): void;
	jointConfigureMotorPosition(handle: number, axis: RawJointAxis, targetPos: number, stiffness: number, damping: number): void;
	jointConfigureMotor(handle: number, axis: RawJointAxis, targetPos: number, targetVel: number, stiffness: number, damping: number): void;
	constructor();
	createJoint(params: RawGenericJoint, parent1: number, parent2: number, wake_up: boolean): number;
	remove(handle: number, wakeUp: boolean): void;
	len(): number;
	contains(handle: number): boolean;
	/**
	 * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.
	 *
	 * # Parameters
	 * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.
	 */
	forEachJointHandle(f: Function): void;
	/**
	 * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.
	 *
	 * # Parameters
	 * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.
	 */
	forEachJointAttachedToRigidBody(body: number, f: Function): void;
}
class RawIntegrationParameters {
	free(): void;
	constructor();
	dt: number;
	readonly contact_erp: number;
	normalizedAllowedLinearError: number;
	normalizedPredictionDistance: number;
	numSolverIterations: number;
	numInternalPgsIterations: number;
	minIslandSize: number;
	maxCcdSubsteps: number;
	lengthUnit: number;
	set contact_natural_frequency(value: number);
}
class RawIslandManager {
	free(): void;
	constructor();
	/**
	 * Applies the given JavaScript function to the integer handle of each active rigid-body
	 * managed by this island manager.
	 *
	 * After a short time of inactivity, a rigid-body is automatically deactivated ("asleep") by
	 * the physics engine in order to save computational power. A sleeping rigid-body never moves
	 * unless it is moved manually by the user.
	 *
	 * # Parameters
	 * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this
	 *   set. Called as `f(collider)`.
	 */
	forEachActiveRigidBodyHandle(f: Function): void;
}
class RawMultibodyJointSet {
	free(): void;
	/**
	 * The type of this joint.
	 */
	jointType(handle: number): RawJointType;
	/**
	 * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.
	 */
	jointFrameX1(handle: number): RawRotation;
	/**
	 * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.
	 */
	jointFrameX2(handle: number): RawRotation;
	/**
	 * The position of the first anchor of this joint.
	 *
	 * The first anchor gives the position of the points application point on the
	 * local frame of the first rigid-body it is attached to.
	 */
	jointAnchor1(handle: number): RawVector;
	/**
	 * The position of the second anchor of this joint.
	 *
	 * The second anchor gives the position of the points application point on the
	 * local frame of the second rigid-body it is attached to.
	 */
	jointAnchor2(handle: number): RawVector;
	/**
	 * Are contacts between the rigid-bodies attached by this joint enabled?
	 */
	jointContactsEnabled(handle: number): boolean;
	/**
	 * Sets whether contacts are enabled between the rigid-bodies attached by this joint.
	 */
	jointSetContactsEnabled(handle: number, enabled: boolean): void;
	/**
	 * Are the limits for this joint enabled?
	 */
	jointLimitsEnabled(handle: number, axis: RawJointAxis): boolean;
	/**
	 * Return the lower limit along the given joint axis.
	 */
	jointLimitsMin(handle: number, axis: RawJointAxis): number;
	/**
	 * If this is a prismatic joint, returns its upper limit.
	 */
	jointLimitsMax(handle: number, axis: RawJointAxis): number;
	constructor();
	createJoint(params: RawGenericJoint, parent1: number, parent2: number, wakeUp: boolean): number;
	remove(handle: number, wakeUp: boolean): void;
	contains(handle: number): boolean;
	/**
	 * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.
	 *
	 * # Parameters
	 * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.
	 */
	forEachJointHandle(f: Function): void;
	/**
	 * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.
	 *
	 * # Parameters
	 * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.
	 */
	forEachJointAttachedToRigidBody(body: number, f: Function): void;
}
class RawNarrowPhase {
	free(): void;
	constructor();
	contact_pairs_with(handle1: number, f: Function): void;
	contact_pair(handle1: number, handle2: number): RawContactPair | undefined;
	intersection_pairs_with(handle1: number, f: Function): void;
	intersection_pair(handle1: number, handle2: number): boolean;
}
class RawPhysicsPipeline {
	free(): void;
	constructor();
	set_profiler_enabled(enabled: boolean): void;
	is_profiler_enabled(): boolean;
	timing_step(): number;
	timing_collision_detection(): number;
	timing_broad_phase(): number;
	timing_narrow_phase(): number;
	timing_solver(): number;
	timing_velocity_assembly(): number;
	timing_velocity_resolution(): number;
	timing_velocity_update(): number;
	timing_velocity_writeback(): number;
	timing_ccd(): number;
	timing_ccd_toi_computation(): number;
	timing_ccd_broad_phase(): number;
	timing_ccd_narrow_phase(): number;
	timing_ccd_solver(): number;
	timing_island_construction(): number;
	timing_user_changes(): number;
	step(gravity: RawVector, integrationParameters: RawIntegrationParameters, islands: RawIslandManager, broadPhase: RawBroadPhase, narrowPhase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, joints: RawImpulseJointSet, articulations: RawMultibodyJointSet, ccd_solver: RawCCDSolver): void;
	stepWithEvents(gravity: RawVector, integrationParameters: RawIntegrationParameters, islands: RawIslandManager, broadPhase: RawBroadPhase, narrowPhase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, joints: RawImpulseJointSet, articulations: RawMultibodyJointSet, ccd_solver: RawCCDSolver, eventQueue: RawEventQueue, hookObject: object, hookFilterContactPair: Function, hookFilterIntersectionPair: Function): void;
}
class RawPointColliderProjection {
	private constructor();
	free(): void;
	colliderHandle(): number;
	point(): RawVector;
	isInside(): boolean;
	featureType(): RawFeatureType;
	featureId(): number | undefined;
}
class RawPointProjection {
	private constructor();
	free(): void;
	point(): RawVector;
	isInside(): boolean;
}
class RawRayColliderHit {
	private constructor();
	free(): void;
	colliderHandle(): number;
	timeOfImpact(): number;
}
class RawRayColliderIntersection {
	private constructor();
	free(): void;
	colliderHandle(): number;
	normal(): RawVector;
	time_of_impact(): number;
	featureType(): RawFeatureType;
	featureId(): number | undefined;
}
class RawRayIntersection {
	private constructor();
	free(): void;
	normal(): RawVector;
	time_of_impact(): number;
	featureType(): RawFeatureType;
	featureId(): number | undefined;
}
class RawRigidBodySet {
	free(): void;
	/**
	 * The world-space translation of this rigid-body.
	 */
	rbTranslation(handle: number): RawVector;
	/**
	 * The world-space orientation of this rigid-body.
	 */
	rbRotation(handle: number): RawRotation;
	/**
	 * Put the given rigid-body to sleep.
	 */
	rbSleep(handle: number): void;
	/**
	 * Is this rigid-body sleeping?
	 */
	rbIsSleeping(handle: number): boolean;
	/**
	 * Is the velocity of this rigid-body not zero?
	 */
	rbIsMoving(handle: number): boolean;
	/**
	 * The world-space predicted translation of this rigid-body.
	 *
	 * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`
	 * method and is used for estimating the kinematic body velocity at the next timestep.
	 * For non-kinematic bodies, this value is currently unspecified.
	 */
	rbNextTranslation(handle: number): RawVector;
	/**
	 * The world-space predicted orientation of this rigid-body.
	 *
	 * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`
	 * method and is used for estimating the kinematic body velocity at the next timestep.
	 * For non-kinematic bodies, this value is currently unspecified.
	 */
	rbNextRotation(handle: number): RawRotation;
	/**
	 * Sets the translation of this rigid-body.
	 *
	 * # Parameters
	 * - `x`: the world-space position of the rigid-body along the `x` axis.
	 * - `y`: the world-space position of the rigid-body along the `y` axis.
	 * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it
	 * wasn't moving before modifying its position.
	 */
	rbSetTranslation(handle: number, x: number, y: number, wakeUp: boolean): void;
	/**
	 * Sets the rotation angle of this rigid-body.
	 *
	 * # Parameters
	 * - `angle`: the rotation angle, in radians.
	 * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it
	 * wasn't moving before modifying its position.
	 */
	rbSetRotation(handle: number, angle: number, wakeUp: boolean): void;
	/**
	 * Sets the linear velocity of this rigid-body.
	 */
	rbSetLinvel(handle: number, linvel: RawVector, wakeUp: boolean): void;
	/**
	 * Sets the angular velocity of this rigid-body.
	 */
	rbSetAngvel(handle: number, angvel: number, wakeUp: boolean): void;
	/**
	 * If this rigid body is kinematic, sets its future translation after the next timestep integration.
	 *
	 * This should be used instead of `rigidBody.setTranslation` to make the dynamic object
	 * interacting with this kinematic body behave as expected. Internally, Rapier will compute
	 * an artificial velocity for this rigid-body from its current position and its next kinematic
	 * position. This velocity will be used to compute forces on dynamic bodies interacting with
	 * this body.
	 *
	 * # Parameters
	 * - `x`: the world-space position of the rigid-body along the `x` axis.
	 * - `y`: the world-space position of the rigid-body along the `y` axis.
	 */
	rbSetNextKinematicTranslation(handle: number, x: number, y: number): void;
	/**
	 * If this rigid body is kinematic, sets its future rotation after the next timestep integration.
	 *
	 * This should be used instead of `rigidBody.setRotation` to make the dynamic object
	 * interacting with this kinematic body behave as expected. Internally, Rapier will compute
	 * an artificial velocity for this rigid-body from its current position and its next kinematic
	 * position. This velocity will be used to compute forces on dynamic bodies interacting with
	 * this body.
	 *
	 * # Parameters
	 * - `angle`: the rotation angle, in radians.
	 */
	rbSetNextKinematicRotation(handle: number, angle: number): void;
	rbRecomputeMassPropertiesFromColliders(handle: number, colliders: RawColliderSet): void;
	rbSetAdditionalMass(handle: number, mass: number, wake_up: boolean): void;
	rbSetAdditionalMassProperties(handle: number, mass: number, centerOfMass: RawVector, principalAngularInertia: number, wake_up: boolean): void;
	/**
	 * The linear velocity of this rigid-body.
	 */
	rbLinvel(handle: number): RawVector;
	/**
	 * The angular velocity of this rigid-body.
	 */
	rbAngvel(handle: number): number;
	/**
	 * The velocity of the given world-space point on this rigid-body.
	 */
	rbVelocityAtPoint(handle: number, point: RawVector): RawVector;
	rbLockTranslations(handle: number, locked: boolean, wake_up: boolean): void;
	rbSetEnabledTranslations(handle: number, allow_x: boolean, allow_y: boolean, wake_up: boolean): void;
	rbLockRotations(handle: number, locked: boolean, wake_up: boolean): void;
	rbDominanceGroup(handle: number): number;
	rbSetDominanceGroup(handle: number, group: number): void;
	rbEnableCcd(handle: number, enabled: boolean): void;
	rbSetSoftCcdPrediction(handle: number, prediction: number): void;
	/**
	 * The mass of this rigid-body.
	 */
	rbMass(handle: number): number;
	/**
	 * The inverse of the mass of a rigid-body.
	 *
	 * If this is zero, the rigid-body is assumed to have infinite mass.
	 */
	rbInvMass(handle: number): number;
	/**
	 * The inverse mass taking into account translation locking.
	 */
	rbEffectiveInvMass(handle: number): RawVector;
	/**
	 * The center of mass of a rigid-body expressed in its local-space.
	 */
	rbLocalCom(handle: number): RawVector;
	/**
	 * The world-space center of mass of the rigid-body.
	 */
	rbWorldCom(handle: number): RawVector;
	/**
	 * The inverse of the principal angular inertia of the rigid-body.
	 *
	 * Components set to zero are assumed to be infinite along the corresponding principal axis.
	 */
	rbInvPrincipalInertia(handle: number): number;
	/**
	 * The angular inertia along the principal inertia axes of the rigid-body.
	 */
	rbPrincipalInertia(handle: number): number;
	/**
	 * The world-space inverse angular inertia tensor of the rigid-body,
	 * taking into account rotation locking.
	 */
	rbEffectiveWorldInvInertia(handle: number): number;
	/**
	 * The effective world-space angular inertia (that takes the potential rotation locking into account) of
	 * this rigid-body.
	 */
	rbEffectiveAngularInertia(handle: number): number;
	/**
	 * Wakes this rigid-body up.
	 *
	 * A dynamic rigid-body that does not move during several consecutive frames will
	 * be put to sleep by the physics engine, i.e., it will stop being simulated in order
	 * to avoid useless computations.
	 * This method forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying
	 * the position of a dynamic body so that it is properly simulated afterwards.
	 */
	rbWakeUp(handle: number): void;
	/**
	 * Is Continuous Collision Detection enabled for this rigid-body?
	 */
	rbIsCcdEnabled(handle: number): boolean;
	rbSoftCcdPrediction(handle: number): number;
	/**
	 * The number of colliders attached to this rigid-body.
	 */
	rbNumColliders(handle: number): number;
	/**
	 * Retrieves the `i-th` collider attached to this rigid-body.
	 *
	 * # Parameters
	 * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.
	 *         This index is **not** the same as the unique identifier of the collider.
	 */
	rbCollider(handle: number, at: number): number;
	/**
	 * The status of this rigid-body: fixed, dynamic, or kinematic.
	 */
	rbBodyType(handle: number): RawRigidBodyType;
	/**
	 * Set a new status for this rigid-body: fixed, dynamic, or kinematic.
	 */
	rbSetBodyType(handle: number, status: RawRigidBodyType, wake_up: boolean): void;
	/**
	 * Is this rigid-body fixed?
	 */
	rbIsFixed(handle: number): boolean;
	/**
	 * Is this rigid-body kinematic?
	 */
	rbIsKinematic(handle: number): boolean;
	/**
	 * Is this rigid-body dynamic?
	 */
	rbIsDynamic(handle: number): boolean;
	/**
	 * The linear damping coefficient of this rigid-body.
	 */
	rbLinearDamping(handle: number): number;
	/**
	 * The angular damping coefficient of this rigid-body.
	 */
	rbAngularDamping(handle: number): number;
	rbSetLinearDamping(handle: number, factor: number): void;
	rbSetAngularDamping(handle: number, factor: number): void;
	rbSetEnabled(handle: number, enabled: boolean): void;
	rbIsEnabled(handle: number): boolean;
	rbGravityScale(handle: number): number;
	rbSetGravityScale(handle: number, factor: number, wakeUp: boolean): void;
	/**
	 * Resets to zero all user-added forces added to this rigid-body.
	 */
	rbResetForces(handle: number, wakeUp: boolean): void;
	/**
	 * Resets to zero all user-added torques added to this rigid-body.
	 */
	rbResetTorques(handle: number, wakeUp: boolean): void;
	/**
	 * Adds a force at the center-of-mass of this rigid-body.
	 *
	 * # Parameters
	 * - `force`: the world-space force to apply on the rigid-body.
	 * - `wakeUp`: should the rigid-body be automatically woken-up?
	 */
	rbAddForce(handle: number, force: RawVector, wakeUp: boolean): void;
	/**
	 * Applies an impulse at the center-of-mass of this rigid-body.
	 *
	 * # Parameters
	 * - `impulse`: the world-space impulse to apply on the rigid-body.
	 * - `wakeUp`: should the rigid-body be automatically woken-up?
	 */
	rbApplyImpulse(handle: number, impulse: RawVector, wakeUp: boolean): void;
	/**
	 * Adds a torque at the center-of-mass of this rigid-body.
	 *
	 * # Parameters
	 * - `torque`: the torque to apply on the rigid-body.
	 * - `wakeUp`: should the rigid-body be automatically woken-up?
	 */
	rbAddTorque(handle: number, torque: number, wakeUp: boolean): void;
	/**
	 * Applies an impulsive torque at the center-of-mass of this rigid-body.
	 *
	 * # Parameters
	 * - `torque impulse`: the torque impulse to apply on the rigid-body.
	 * - `wakeUp`: should the rigid-body be automatically woken-up?
	 */
	rbApplyTorqueImpulse(handle: number, torque_impulse: number, wakeUp: boolean): void;
	/**
	 * Adds a force at the given world-space point of this rigid-body.
	 *
	 * # Parameters
	 * - `force`: the world-space force to apply on the rigid-body.
	 * - `point`: the world-space point where the impulse is to be applied on the rigid-body.
	 * - `wakeUp`: should the rigid-body be automatically woken-up?
	 */
	rbAddForceAtPoint(handle: number, force: RawVector, point: RawVector, wakeUp: boolean): void;
	/**
	 * Applies an impulse at the given world-space point of this rigid-body.
	 *
	 * # Parameters
	 * - `impulse`: the world-space impulse to apply on the rigid-body.
	 * - `point`: the world-space point where the impulse is to be applied on the rigid-body.
	 * - `wakeUp`: should the rigid-body be automatically woken-up?
	 */
	rbApplyImpulseAtPoint(handle: number, impulse: RawVector, point: RawVector, wakeUp: boolean): void;
	rbAdditionalSolverIterations(handle: number): number;
	rbSetAdditionalSolverIterations(handle: number, iters: number): void;
	/**
	 * An arbitrary user-defined 32-bit integer
	 */
	rbUserData(handle: number): number;
	/**
	 * Sets the user-defined 32-bit integer of this rigid-body.
	 *
	 * # Parameters
	 * - `data`: an arbitrary user-defined 32-bit integer.
	 */
	rbSetUserData(handle: number, data: number): void;
	/**
	 * Retrieves the constant force(s) the user added to this rigid-body.
	 * Returns zero if the rigid-body is not dynamic.
	 */
	rbUserForce(handle: number): RawVector;
	/**
	 * Retrieves the constant torque(s) the user added to this rigid-body.
	 * Returns zero if the rigid-body is not dynamic.
	 */
	rbUserTorque(handle: number): number;
	constructor();
	createRigidBody(enabled: boolean, translation: RawVector, rotation: RawRotation, gravityScale: number, mass: number, massOnly: boolean, centerOfMass: RawVector, linvel: RawVector, angvel: number, principalAngularInertia: number, translationEnabledX: boolean, translationEnabledY: boolean, rotationsEnabled: boolean, linearDamping: number, angularDamping: number, rb_type: RawRigidBodyType, canSleep: boolean, sleeping: boolean, softCcdPrediciton: number, ccdEnabled: boolean, dominanceGroup: number, additional_solver_iterations: number): number;
	remove(handle: number, islands: RawIslandManager, colliders: RawColliderSet, joints: RawImpulseJointSet, articulations: RawMultibodyJointSet): void;
	/**
	 * The number of rigid-bodies on this set.
	 */
	len(): number;
	/**
	 * Checks if a rigid-body with the given integer handle exists.
	 */
	contains(handle: number): boolean;
	/**
	 * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.
	 *
	 * # Parameters
	 * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.
	 */
	forEachRigidBodyHandle(f: Function): void;
	propagateModifiedBodyPositionsToColliders(colliders: RawColliderSet): void;
}
class RawRotation {
	private constructor();
	free(): void;
	/**
	 * The identity rotation.
	 */
	static identity(): RawRotation;
	/**
	 * The rotation with thegiven angle.
	 */
	static fromAngle(angle: number): RawRotation;
	/**
	 * The imaginary part of this complex number.
	 */
	readonly im: number;
	/**
	 * The real part of this complex number.
	 */
	readonly re: number;
	/**
	 * The rotation angle in radians.
	 */
	readonly angle: number;
}
class RawSerializationPipeline {
	free(): void;
	constructor();
	serializeAll(gravity: RawVector, integrationParameters: RawIntegrationParameters, islands: RawIslandManager, broadPhase: RawBroadPhase, narrowPhase: RawNarrowPhase, bodies: RawRigidBodySet, colliders: RawColliderSet, impulse_joints: RawImpulseJointSet, multibody_joints: RawMultibodyJointSet): Uint8Array | undefined;
	deserializeAll(data: Uint8Array): RawDeserializedWorld | undefined;
}
class RawShape {
	private constructor();
	free(): void;
	static cuboid(hx: number, hy: number): RawShape;
	static roundCuboid(hx: number, hy: number, borderRadius: number): RawShape;
	static ball(radius: number): RawShape;
	static halfspace(normal: RawVector): RawShape;
	static capsule(halfHeight: number, radius: number): RawShape;
	static voxels(voxel_size: RawVector, grid_coords: Int32Array): RawShape;
	static voxelsFromPoints(voxel_size: RawVector, points: Float32Array): RawShape;
	static polyline(vertices: Float32Array, indices: Uint32Array): RawShape;
	static trimesh(vertices: Float32Array, indices: Uint32Array, flags: number): RawShape | undefined;
	static heightfield(heights: Float32Array, scale: RawVector): RawShape;
	static segment(p1: RawVector, p2: RawVector): RawShape;
	static triangle(p1: RawVector, p2: RawVector, p3: RawVector): RawShape;
	static roundTriangle(p1: RawVector, p2: RawVector, p3: RawVector, borderRadius: number): RawShape;
	static convexHull(points: Float32Array): RawShape | undefined;
	static roundConvexHull(points: Float32Array, borderRadius: number): RawShape | undefined;
	static convexPolyline(vertices: Float32Array): RawShape | undefined;
	static roundConvexPolyline(vertices: Float32Array, borderRadius: number): RawShape | undefined;
	castShape(shapePos1: RawVector, shapeRot1: RawRotation, shapeVel1: RawVector, shape2: RawShape, shapePos2: RawVector, shapeRot2: RawRotation, shapeVel2: RawVector, target_distance: number, maxToi: number, stop_at_penetration: boolean): RawShapeCastHit | undefined;
	intersectsShape(shapePos1: RawVector, shapeRot1: RawRotation, shape2: RawShape, shapePos2: RawVector, shapeRot2: RawRotation): boolean;
	contactShape(shapePos1: RawVector, shapeRot1: RawRotation, shape2: RawShape, shapePos2: RawVector, shapeRot2: RawRotation, prediction: number): RawShapeContact | undefined;
	containsPoint(shapePos: RawVector, shapeRot: RawRotation, point: RawVector): boolean;
	projectPoint(shapePos: RawVector, shapeRot: RawRotation, point: RawVector, solid: boolean): RawPointProjection;
	intersectsRay(shapePos: RawVector, shapeRot: RawRotation, rayOrig: RawVector, rayDir: RawVector, maxToi: number): boolean;
	castRay(shapePos: RawVector, shapeRot: RawRotation, rayOrig: RawVector, rayDir: RawVector, maxToi: number, solid: boolean): number;
	castRayAndGetNormal(shapePos: RawVector, shapeRot: RawRotation, rayOrig: RawVector, rayDir: RawVector, maxToi: number, solid: boolean): RawRayIntersection | undefined;
}
class RawShapeCastHit {
	private constructor();
	free(): void;
	time_of_impact(): number;
	witness1(): RawVector;
	witness2(): RawVector;
	normal1(): RawVector;
	normal2(): RawVector;
}
class RawShapeContact {
	private constructor();
	free(): void;
	distance(): number;
	point1(): RawVector;
	point2(): RawVector;
	normal1(): RawVector;
	normal2(): RawVector;
}
class RawVector {
	free(): void;
	/**
	 * Creates a new vector filled with zeros.
	 */
	static zero(): RawVector;
	/**
	 * Creates a new 2D vector from its two components.
	 *
	 * # Parameters
	 * - `x`: the `x` component of this 2D vector.
	 * - `y`: the `y` component of this 2D vector.
	 */
	constructor(x: number, y: number);
	/**
	 * Create a new 2D vector from this vector with its components rearranged as `{x, y}`.
	 */
	xy(): RawVector;
	/**
	 * Create a new 2D vector from this vector with its components rearranged as `{y, x}`.
	 */
	yx(): RawVector;
	/**
	 * The `x` component of this vector.
	 */
	x: number;
	/**
	 * The `y` component of this vector.
	 */
	y: number;
}
export interface Vector {
	x: number;
	y: number;
}
/**
 * A rotation angle in radians.
 */
type Rotation = number;
enum ActiveEvents {
	NONE = 0,
	/**
	 * Enable collision events.
	 */
	COLLISION_EVENTS = 1,
	/**
	 * Enable contact force events.
	 */
	CONTACT_FORCE_EVENTS = 2
}
class TempContactForceEvent {
	raw: RawContactForceEvent;
	free(): void;
	/**
	 * The first collider involved in the contact.
	 */
	collider1(): ColliderHandle;
	/**
	 * The second collider involved in the contact.
	 */
	collider2(): ColliderHandle;
	/**
	 * The sum of all the forces between the two colliders.
	 */
	totalForce(): Vector;
	/**
	 * The sum of the magnitudes of each force between the two colliders.
	 *
	 * Note that this is **not** the same as the magnitude of `self.total_force`.
	 * Here we are summing the magnitude of all the forces, instead of taking
	 * the magnitude of their sum.
	 */
	totalForceMagnitude(): number;
	/**
	 * The world-space (unit) direction of the force with strongest magnitude.
	 */
	maxForceDirection(): Vector;
	/**
	 * The magnitude of the largest force at a contact point of this contact pair.
	 */
	maxForceMagnitude(): number;
}
class EventQueue {
	raw: RawEventQueue;
	/**
	 * Creates a new event collector.
	 *
	 * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will
	 * be automatically drained before each `world.step(collector)`. If false, the collector will
	 * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of
	 * RAM if no drain is performed.
	 */
	constructor(autoDrain: boolean, raw?: RawEventQueue);
	/**
	 * Release the WASM memory occupied by this event-queue.
	 */
	free(): void;
	/**
	 * Applies the given javascript closure on each collision event of this collector, then clear
	 * the internal collision event buffer.
	 *
	 * @param f - JavaScript closure applied to each collision event. The
	 * closure must take three arguments: two integers representing the handles of the colliders
	 * involved in the collision, and a boolean indicating if the collision started (true) or stopped
	 * (false).
	 */
	drainCollisionEvents(f: (handle1: ColliderHandle, handle2: ColliderHandle, started: boolean) => void): void;
	/**
	 * Applies the given javascript closure on each contact force event of this collector, then clear
	 * the internal collision event buffer.
	 *
	 * @param f - JavaScript closure applied to each collision event. The
	 *            closure must take one `TempContactForceEvent` argument.
	 */
	drainContactForceEvents(f: (event: TempContactForceEvent) => void): void;
	/**
	 * Removes all events contained by this collector
	 */
	clear(): void;
}
enum ActiveHooks {
	NONE = 0,
	FILTER_CONTACT_PAIRS = 1,
	FILTER_INTERSECTION_PAIRS = 2
}
enum SolverFlags {
	EMPTY = 0,
	COMPUTE_IMPULSE = 1
}
export interface PhysicsHooks {
	/**
	 * Function that determines if contacts computation should happen between two colliders, and how the
	 * constraints solver should behave for these contacts.
	 *
	 * This will only be executed and taken into account if at least one of the involved colliders contains the
	 * `ActiveHooks.FILTER_CONTACT_PAIR` flag in its active hooks.
	 *
	 * @param collider1 − Handle of the first collider involved in the potential contact.
	 * @param collider2 − Handle of the second collider involved in the potential contact.
	 * @param body1 − Handle of the first body involved in the potential contact.
	 * @param body2 − Handle of the second body involved in the potential contact.
	 */
	filterContactPair(collider1: ColliderHandle, collider2: ColliderHandle, body1: RigidBodyHandle, body2: RigidBodyHandle): SolverFlags | null;
	/**
	 * Function that determines if intersection computation should happen between two colliders (where at least
	 * one is a sensor).
	 *
	 * This will only be executed and taken into account if `one of the involved colliders contains the
	 * `ActiveHooks.FILTER_INTERSECTION_PAIR` flag in its active hooks.
	 *
	 * @param collider1 − Handle of the first collider involved in the potential contact.
	 * @param collider2 − Handle of the second collider involved in the potential contact.
	 * @param body1 − Handle of the first body involved in the potential contact.
	 * @param body2 − Handle of the second body involved in the potential contact.
	 */
	filterIntersectionPair(collider1: ColliderHandle, collider2: ColliderHandle, body1: RigidBodyHandle, body2: RigidBodyHandle): boolean;
}
class PhysicsPipeline {
	raw: RawPhysicsPipeline;
	free(): void;
	constructor(raw?: RawPhysicsPipeline);
	step(gravity: Vector, integrationParameters: IntegrationParameters, islands: IslandManager, broadPhase: BroadPhase, narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, impulseJoints: ImpulseJointSet, multibodyJoints: MultibodyJointSet, ccdSolver: CCDSolver, eventQueue?: EventQueue, hooks?: PhysicsHooks): void;
}
enum QueryFilterFlags {
	/**
	 * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.
	 */
	EXCLUDE_FIXED = 1,
	/**
	 * Exclude from the query any collider attached to a dynamic rigid-body.
	 */
	EXCLUDE_KINEMATIC = 2,
	/**
	 * Exclude from the query any collider attached to a kinematic rigid-body.
	 */
	EXCLUDE_DYNAMIC = 4,
	/**
	 * Exclude from the query any collider that is a sensor.
	 */
	EXCLUDE_SENSORS = 8,
	/**
	 * Exclude from the query any collider that is not a sensor.
	 */
	EXCLUDE_SOLIDS = 16,
	/**
	 * Excludes all colliders not attached to a dynamic rigid-body.
	 */
	ONLY_DYNAMIC = 3,
	/**
	 * Excludes all colliders not attached to a kinematic rigid-body.
	 */
	ONLY_KINEMATIC = 5,
	/**
	 * Exclude all colliders attached to a non-fixed rigid-body
	 * (this will not exclude colliders not attached to any rigid-body).
	 */
	ONLY_FIXED = 6
}
class SerializationPipeline {
	raw: RawSerializationPipeline;
	/**
	 * Release the WASM memory occupied by this serialization pipeline.
	 */
	free(): void;
	constructor(raw?: RawSerializationPipeline);
	/**
	 * Serialize a complete physics state into a single byte array.
	 * @param gravity - The current gravity affecting the simulation.
	 * @param integrationParameters - The integration parameters of the simulation.
	 * @param broadPhase - The broad-phase of the simulation.
	 * @param narrowPhase - The narrow-phase of the simulation.
	 * @param bodies - The rigid-bodies taking part into the simulation.
	 * @param colliders - The colliders taking part into the simulation.
	 * @param impulseJoints - The impulse joints taking part into the simulation.
	 * @param multibodyJoints - The multibody joints taking part into the simulation.
	 */
	serializeAll(gravity: Vector, integrationParameters: IntegrationParameters, islands: IslandManager, broadPhase: BroadPhase, narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, impulseJoints: ImpulseJointSet, multibodyJoints: MultibodyJointSet): Uint8Array;
	/**
	 * Deserialize the complete physics state from a single byte array.
	 *
	 * @param data - The byte array to deserialize.
	 */
	deserializeAll(data: Uint8Array): World;
}
class DebugRenderBuffers {
	/**
	 * The lines to render. This is a flat array containing all the lines
	 * to render. Each line is described as two consecutive point. Each
	 * point is described as two (in 2D) or three (in 3D) consecutive
	 * floats. For example, in 2D, the array: `[1, 2, 3, 4, 5, 6, 7, 8]`
	 * describes the two segments `[[1, 2], [3, 4]]` and `[[5, 6], [7, 8]]`.
	 */
	vertices: Float32Array;
	/**
	 * The color buffer. There is one color per vertex, and each color
	 * has four consecutive components (in RGBA format).
	 */
	colors: Float32Array;
	constructor(vertices: Float32Array, colors: Float32Array);
}
class DebugRenderPipeline {
	raw: RawDebugRenderPipeline;
	vertices: Float32Array;
	colors: Float32Array;
	/**
	 * Release the WASM memory occupied by this serialization pipeline.
	 */
	free(): void;
	constructor(raw?: RawDebugRenderPipeline);
	render(bodies: RigidBodySet, colliders: ColliderSet, impulse_joints: ImpulseJointSet, multibody_joints: MultibodyJointSet, narrow_phase: NarrowPhase, filterFlags?: QueryFilterFlags, filterPredicate?: (collider: Collider) => boolean): void;
}
class CharacterCollision {
	/** The collider involved in the collision. Null if the collider no longer exists in the physics world. */
	collider: Collider | null;
	/** The translation delta applied to the character before this collision took place. */
	translationDeltaApplied: Vector;
	/** The translation delta the character would move after this collision if there is no other obstacles. */
	translationDeltaRemaining: Vector;
	/** The time-of-impact between the character and the obstacles. */
	toi: number;
	/** The world-space contact point on the collider when the collision happens. */
	witness1: Vector;
	/** The local-space contact point on the character when the collision happens. */
	witness2: Vector;
	/** The world-space outward contact normal on the collider when the collision happens. */
	normal1: Vector;
	/** The local-space outward contact normal on the character when the collision happens. */
	normal2: Vector;
}
class KinematicCharacterController {
	private raw;
	private rawCharacterCollision;
	private params;
	private broadPhase;
	private narrowPhase;
	private bodies;
	private colliders;
	private _applyImpulsesToDynamicBodies;
	private _characterMass;
	constructor(offset: number, params: IntegrationParameters, broadPhase: BroadPhase, narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet);
	/** @internal */
	free(): void;
	/**
	 * The direction that goes "up". Used to determine where the floor is, and the floor’s angle.
	 */
	up(): Vector;
	/**
	 * Sets the direction that goes "up". Used to determine where the floor is, and the floor’s angle.
	 */
	setUp(vector: Vector): void;
	applyImpulsesToDynamicBodies(): boolean;
	setApplyImpulsesToDynamicBodies(enabled: boolean): void;
	/**
	 * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.
	 */
	characterMass(): number | null;
	/**
	 * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`
	 * is set to `true`.
	 *
	 * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal
	 * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider
	 * isn’t attached to any rigid-body.
	 *
	 * @param mass - The mass to set.
	 */
	setCharacterMass(mass: number | null): void;
	/**
	 * A small gap to preserve between the character and its surroundings.
	 *
	 * This value should not be too large to avoid visual artifacts, but shouldn’t be too small
	 * (must not be zero) to improve numerical stability of the character controller.
	 */
	offset(): number;
	/**
	 * Sets a small gap to preserve between the character and its surroundings.
	 *
	 * This value should not be too large to avoid visual artifacts, but shouldn’t be too small
	 * (must not be zero) to improve numerical stability of the character controller.
	 */
	setOffset(value: number): void;
	normalNudgeFactor(): number;
	setNormalNudgeFactor(value: number): void;
	/**
	 * Is sliding against obstacles enabled?
	 */
	slideEnabled(): boolean;
	/**
	 * Enable or disable sliding against obstacles.
	 */
	setSlideEnabled(enabled: boolean): void;
	/**
	 * The maximum step height a character can automatically step over.
	 */
	autostepMaxHeight(): number | null;
	/**
	 * The minimum width of free space that must be available after stepping on a stair.
	 */
	autostepMinWidth(): number | null;
	/**
	 * Can the character automatically step over dynamic bodies too?
	 */
	autostepIncludesDynamicBodies(): boolean | null;
	/**
	 * Is automatically stepping over small objects enabled?
	 */
	autostepEnabled(): boolean;
	/**
	 * Enabled automatically stepping over small objects.
	 *
	 * @param maxHeight - The maximum step height a character can automatically step over.
	 * @param minWidth - The minimum width of free space that must be available after stepping on a stair.
	 * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?
	 */
	enableAutostep(maxHeight: number, minWidth: number, includeDynamicBodies: boolean): void;
	/**
	 * Disable automatically stepping over small objects.
	 */
	disableAutostep(): void;
	/**
	 * The maximum angle (radians) between the floor’s normal and the `up` vector that the
	 * character is able to climb.
	 */
	maxSlopeClimbAngle(): number;
	/**
	 * Sets the maximum angle (radians) between the floor’s normal and the `up` vector that the
	 * character is able to climb.
	 */
	setMaxSlopeClimbAngle(angle: number): void;
	/**
	 * The minimum angle (radians) between the floor’s normal and the `up` vector before the
	 * character starts to slide down automatically.
	 */
	minSlopeSlideAngle(): number;
	/**
	 * Sets the minimum angle (radians) between the floor’s normal and the `up` vector before the
	 * character starts to slide down automatically.
	 */
	setMinSlopeSlideAngle(angle: number): void;
	/**
	 * If snap-to-ground is enabled, should the character be automatically snapped to the ground if
	 * the distance between the ground and its feet are smaller than the specified threshold?
	 */
	snapToGroundDistance(): number | null;
	/**
	 * Enables automatically snapping the character to the ground if the distance between
	 * the ground and its feet are smaller than the specified threshold.
	 */
	enableSnapToGround(distance: number): void;
	/**
	 * Disables automatically snapping the character to the ground.
	 */
	disableSnapToGround(): void;
	/**
	 * Is automatically snapping the character to the ground enabled?
	 */
	snapToGroundEnabled(): boolean;
	/**
	 * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.
	 *
	 * @param collider - The collider to move.
	 * @param desiredTranslationDelta - The desired collider movement.
	 * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.
	 * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles
	 *                       taken into account.
	 * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the
	 *                          obstacles taken into account.
	 */
	computeColliderMovement(collider: Collider, desiredTranslationDelta: Vector, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterPredicate?: (collider: Collider) => boolean): void;
	/**
	 * The movement computed by the last call to `this.computeColliderMovement`.
	 */
	computedMovement(): Vector;
	/**
	 * The result of ground detection computed by the last call to `this.computeColliderMovement`.
	 */
	computedGrounded(): boolean;
	/**
	 * The number of collisions against obstacles detected along the path of the last call
	 * to `this.computeColliderMovement`.
	 */
	numComputedCollisions(): number;
	/**
	 * Returns the collision against one of the obstacles detected along the path of the last
	 * call to `this.computeColliderMovement`.
	 *
	 * @param i - The i-th collision will be returned.
	 * @param out - If this argument is set, it will be filled with the collision information.
	 */
	computedCollision(i: number, out?: CharacterCollision): CharacterCollision | null;
}
enum PidAxesMask {
	None = 0,
	LinX = 1,
	LinY = 2,
	LinZ = 4,
	AngZ = 32,
	AllLin = 3,
	AllAng = 32,
	All = 35
}
class PidController {
	private raw;
	private params;
	private bodies;
	constructor(params: IntegrationParameters, bodies: RigidBodySet, kp: number, ki: number, kd: number, axes: PidAxesMask);
	/** @internal */
	free(): void;
	setKp(kp: number, axes: PidAxesMask): void;
	setKi(ki: number, axes: PidAxesMask): void;
	setKd(kd: number, axes: PidAxesMask): void;
	setAxes(axes: PidAxesMask): void;
	resetIntegrals(): void;
	applyLinearCorrection(body: RigidBody, targetPosition: Vector, targetLinvel: Vector): void;
	applyAngularCorrection(body: RigidBody, targetRotation: number, targetAngVel: number): void;
	linearCorrection(body: RigidBody, targetPosition: Vector, targetLinvel: Vector): Vector;
	angularCorrection(body: RigidBody, targetRotation: number, targetAngVel: number): number;
}
class World {
	gravity: Vector;
	integrationParameters: IntegrationParameters;
	islands: IslandManager;
	broadPhase: BroadPhase;
	narrowPhase: NarrowPhase;
	bodies: RigidBodySet;
	colliders: ColliderSet;
	impulseJoints: ImpulseJointSet;
	multibodyJoints: MultibodyJointSet;
	ccdSolver: CCDSolver;
	physicsPipeline: PhysicsPipeline;
	serializationPipeline: SerializationPipeline;
	debugRenderPipeline: DebugRenderPipeline;
	characterControllers: Set<KinematicCharacterController>;
	pidControllers: Set<PidController>;
	/**
	 * Release the WASM memory occupied by this physics world.
	 *
	 * All the fields of this physics world will be freed as well,
	 * so there is no need to call their `.free()` methods individually.
	 */
	free(): void;
	constructor(gravity: Vector, rawIntegrationParameters?: RawIntegrationParameters, rawIslands?: RawIslandManager, rawBroadPhase?: RawBroadPhase, rawNarrowPhase?: RawNarrowPhase, rawBodies?: RawRigidBodySet, rawColliders?: RawColliderSet, rawImpulseJoints?: RawImpulseJointSet, rawMultibodyJoints?: RawMultibodyJointSet, rawCCDSolver?: RawCCDSolver, rawPhysicsPipeline?: RawPhysicsPipeline, rawSerializationPipeline?: RawSerializationPipeline, rawDebugRenderPipeline?: RawDebugRenderPipeline);
	static fromRaw(raw: RawDeserializedWorld): World;
	/**
	 * Takes a snapshot of this world.
	 *
	 * Use `World.restoreSnapshot` to create a new physics world with a state identical to
	 * the state when `.takeSnapshot()` is called.
	 */
	takeSnapshot(): Uint8Array;
	/**
	 * Creates a new physics world from a snapshot.
	 *
	 * This new physics world will be an identical copy of the snapshoted physics world.
	 */
	static restoreSnapshot(data: Uint8Array): World;
	/**
	 * Computes all the lines (and their colors) needed to render the scene.
	 *
	 * @param filterFlags - Flags for excluding whole subsets of colliders from rendering.
	 * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the
	 *                          debug rendering.
	 */
	debugRender(filterFlags?: QueryFilterFlags, filterPredicate?: (collider: Collider) => boolean): DebugRenderBuffers;
	/**
	 * Advance the simulation by one time step.
	 *
	 * All events generated by the physics engine are ignored.
	 *
	 * @param EventQueue - (optional) structure responsible for collecting
	 *   events generated by the physics engine.
	 */
	step(eventQueue?: EventQueue, hooks?: PhysicsHooks): void;
	/**
	 * Update colliders positions after rigid-bodies moved.
	 *
	 * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is
	 * generally automatically done at the beginning and the end of each simulation step with World.step.
	 * If the positions need to be updated without running a simulation step this method can be called manually.
	 */
	propagateModifiedBodyPositionsToColliders(): void;
	/**
	 * The current simulation timestep.
	 */
	get timestep(): number;
	/**
	 * Sets the new simulation timestep.
	 *
	 * The simulation timestep governs by how much the physics state of the world will
	 * be integrated. A simulation timestep should:
	 * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,
	 * corresponds to the time between two frames of a game running at 60FPS).
	 * - not vary too much during the course of the simulation. A timestep with large variations may
	 * cause instabilities in the simulation.
	 *
	 * @param dt - The timestep length, in seconds.
	 */
	set timestep(dt: number);
	/**
	 * The approximate size of most dynamic objects in the scene.
	 *
	 * See the documentation of the `World.lengthUnit` setter for further details.
	 */
	get lengthUnit(): number;
	/**
	 * The approximate size of most dynamic objects in the scene.
	 *
	 * This value is used internally to estimate some length-based tolerance. In particular, the
	 * values `IntegrationParameters.allowedLinearError`,
	 * `IntegrationParameters.maxPenetrationCorrection`,
	 * `IntegrationParameters.predictionDistance`, `RigidBodyActivation.linearThreshold`
	 * are scaled by this value implicitly.
	 *
	 * This value can be understood as the number of units-per-meter in your physical world compared
	 * to a human-sized world in meter. For example, in a 2d game, if your typical object size is 100
	 * pixels, set the `[`Self::length_unit`]` parameter to 100.0. The physics engine will interpret
	 * it as if 100 pixels is equivalent to 1 meter in its various internal threshold.
	 * (default `1.0`).
	 */
	set lengthUnit(unitsPerMeter: number);
	/**
	 * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).
	 */
	get numSolverIterations(): number;
	/**
	 * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).
	 *
	 * The greater this value is, the most rigid and realistic the physics simulation will be.
	 * However a greater number of iterations is more computationally intensive.
	 *
	 * @param niter - The new number of solver iterations.
	 */
	set numSolverIterations(niter: number);
	/**
	 * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).
	 */
	get numInternalPgsIterations(): number;
	/**
	 * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).
	 *
	 * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than
	 * increasing `numSolverIterations` but is also less computationally expensive.
	 *
	 * @param niter - The new number of internal PGS iterations.
	 */
	set numInternalPgsIterations(niter: number);
	/**
	 * The number of substeps continuous collision-detection can run (default: `1`).
	 */
	get maxCcdSubsteps(): number;
	/**
	 * Sets the number of substeps continuous collision-detection can run (default: `1`).
	 *
	 * CCD operates using a "motion clamping" mechanism where all fast-moving object trajectories will
	 * be truncated to their first impact on their path. The number of CCD substeps beyond 1 indicate how
	 * many times that trajectory will be updated and continued after a hit. This can results in smoother
	 * paths, but at a significant computational cost.
	 *
	 * @param niter - The new maximum number of CCD substeps. Setting to `0` disables CCD entirely.
	 */
	set maxCcdSubsteps(substeps: number);
	/**
	 * Creates a new rigid-body from the given rigid-body descriptor.
	 *
	 * @param body - The description of the rigid-body to create.
	 */
	createRigidBody(body: RigidBodyDesc): RigidBody;
	/**
	 * Creates a new character controller.
	 *
	 * @param offset - The artificial gap added between the character’s chape and its environment.
	 */
	createCharacterController(offset: number): KinematicCharacterController;
	/**
	 * Removes a character controller from this world.
	 *
	 * @param controller - The character controller to remove.
	 */
	removeCharacterController(controller: KinematicCharacterController): void;
	/**
	 * Creates a new PID (Proportional-Integral-Derivative) controller.
	 *
	 * @param kp - The Proportional gain applied to the instantaneous linear position errors.
	 *             This is usually set to a multiple of the inverse of simulation step time
	 *             (e.g. `60` if the delta-time is `1.0 / 60.0`).
	 * @param ki - The linear gain applied to the Integral part of the PID controller.
	 * @param kd - The Derivative gain applied to the instantaneous linear velocity errors.
	 *             This is usually set to a value in `[0.0, 1.0]` where `0.0` implies no damping
	 *             (no correction of velocity errors) and `1.0` implies complete damping (velocity errors
	 *             are corrected in a single simulation step).
	 * @param axes - The axes affected by this controller.
	 *               Only coordinate axes with a bit flags set to `true` will be taken into
	 *               account when calculating the errors and corrections.
	 */
	createPidController(kp: number, ki: number, kd: number, axes: PidAxesMask): PidController;
	/**
	 * Removes a PID controller from this world.
	 *
	 * @param controller - The PID controller to remove.
	 */
	removePidController(controller: PidController): void;
	/**
	 * Creates a new collider.
	 *
	 * @param desc - The description of the collider.
	 * @param parent - The rigid-body this collider is attached to.
	 */
	createCollider(desc: ColliderDesc, parent?: RigidBody): Collider;
	/**
	 * Creates a new impulse joint from the given joint descriptor.
	 *
	 * @param params - The description of the joint to create.
	 * @param parent1 - The first rigid-body attached to this joint.
	 * @param parent2 - The second rigid-body attached to this joint.
	 * @param wakeUp - Should the attached rigid-bodies be awakened?
	 */
	createImpulseJoint(params: JointData, parent1: RigidBody, parent2: RigidBody, wakeUp: boolean): ImpulseJoint;
	/**
	 * Creates a new multibody joint from the given joint descriptor.
	 *
	 * @param params - The description of the joint to create.
	 * @param parent1 - The first rigid-body attached to this joint.
	 * @param parent2 - The second rigid-body attached to this joint.
	 * @param wakeUp - Should the attached rigid-bodies be awakened?
	 */
	createMultibodyJoint(params: JointData, parent1: RigidBody, parent2: RigidBody, wakeUp: boolean): MultibodyJoint;
	/**
	 * Retrieves a rigid-body from its handle.
	 *
	 * @param handle - The integer handle of the rigid-body to retrieve.
	 */
	getRigidBody(handle: RigidBodyHandle): RigidBody;
	/**
	 * Retrieves a collider from its handle.
	 *
	 * @param handle - The integer handle of the collider to retrieve.
	 */
	getCollider(handle: ColliderHandle): Collider;
	/**
	 * Retrieves an impulse joint from its handle.
	 *
	 * @param handle - The integer handle of the impulse joint to retrieve.
	 */
	getImpulseJoint(handle: ImpulseJointHandle): ImpulseJoint;
	/**
	 * Retrieves an multibody joint from its handle.
	 *
	 * @param handle - The integer handle of the multibody joint to retrieve.
	 */
	getMultibodyJoint(handle: MultibodyJointHandle): MultibodyJoint;
	/**
	 * Removes the given rigid-body from this physics world.
	 *
	 * This will remove this rigid-body as well as all its attached colliders and joints.
	 * Every other bodies touching or attached by joints to this rigid-body will be woken-up.
	 *
	 * @param body - The rigid-body to remove.
	 */
	removeRigidBody(body: RigidBody): void;
	/**
	 * Removes the given collider from this physics world.
	 *
	 * @param collider - The collider to remove.
	 * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.
	 */
	removeCollider(collider: Collider, wakeUp: boolean): void;
	/**
	 * Removes the given impulse joint from this physics world.
	 *
	 * @param joint - The impulse joint to remove.
	 * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.
	 */
	removeImpulseJoint(joint: ImpulseJoint, wakeUp: boolean): void;
	/**
	 * Removes the given multibody joint from this physics world.
	 *
	 * @param joint - The multibody joint to remove.
	 * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.
	 */
	removeMultibodyJoint(joint: MultibodyJoint, wakeUp: boolean): void;
	/**
	 * Applies the given closure to each collider managed by this physics world.
	 *
	 * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.
	 */
	forEachCollider(f: (collider: Collider) => void): void;
	/**
	 * Applies the given closure to each rigid-body managed by this physics world.
	 *
	 * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.
	 */
	forEachRigidBody(f: (body: RigidBody) => void): void;
	/**
	 * Applies the given closure to each active rigid-body managed by this physics world.
	 *
	 * After a short time of inactivity, a rigid-body is automatically deactivated ("asleep") by
	 * the physics engine in order to save computational power. A sleeping rigid-body never moves
	 * unless it is moved manually by the user.
	 *
	 * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.
	 */
	forEachActiveRigidBody(f: (body: RigidBody) => void): void;
	/**
	 * Find the closest intersection between a ray and the physics world.
	 *
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
	 *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
	 *   whereas `false` implies that all shapes are hollow for this ray-cast.
	 * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
	 * @param filter - The callback to filter out which collider will be hit.
	 */
	castRay(ray: Ray, maxToi: number, solid: boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): RayColliderHit | null;
	/**
	 * Find the closest intersection between a ray and the physics world.
	 *
	 * This also computes the normal at the hit point.
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
	 *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
	 *   whereas `false` implies that all shapes are hollow for this ray-cast.
	 * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
	 */
	castRayAndGetNormal(ray: Ray, maxToi: number, solid: boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): RayColliderIntersection | null;
	/**
	 * Cast a ray and collects all the intersections between a ray and the scene.
	 *
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
	 *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
	 *   whereas `false` implies that all shapes are hollow for this ray-cast.
	 * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
	 * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.
	 *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.
	 */
	intersectionsWithRay(ray: Ray, maxToi: number, solid: boolean, callback: (intersect: RayColliderIntersection) => boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): void;
	/**
	 * Gets the handle of up to one collider intersecting the given shape.
	 *
	 * @param shapePos - The position of the shape used for the intersection test.
	 * @param shapeRot - The orientation of the shape used for the intersection test.
	 * @param shape - The shape used for the intersection test.
	 * @param groups - The bit groups and filter associated to the ray, in order to only
	 *   hit the colliders with collision groups compatible with the ray's group.
	 */
	intersectionWithShape(shapePos: Vector, shapeRot: Rotation, shape: Shape, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): Collider | null;
	/**
	 * Find the projection of a point on the closest collider.
	 *
	 * @param point - The point to project.
	 * @param solid - If this is set to `true` then the collider shapes are considered to
	 *   be plain (if the point is located inside of a plain shape, its projection is the point
	 *   itself). If it is set to `false` the collider shapes are considered to be hollow
	 *   (if the point is located inside of an hollow shape, it is projected on the shape's
	 *   boundary).
	 * @param groups - The bit groups and filter associated to the point to project, in order to only
	 *   project on colliders with collision groups compatible with the ray's group.
	 */
	projectPoint(point: Vector, solid: boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): PointColliderProjection | null;
	/**
	 * Find the projection of a point on the closest collider.
	 *
	 * @param point - The point to project.
	 * @param groups - The bit groups and filter associated to the point to project, in order to only
	 *   project on colliders with collision groups compatible with the ray's group.
	 */
	projectPointAndGetFeature(point: Vector, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): PointColliderProjection | null;
	/**
	 * Find all the colliders containing the given point.
	 *
	 * @param point - The point used for the containment test.
	 * @param groups - The bit groups and filter associated to the point to test, in order to only
	 *   test on colliders with collision groups compatible with the ray's group.
	 * @param callback - A function called with the handles of each collider with a shape
	 *   containing the `point`.
	 */
	intersectionsWithPoint(point: Vector, callback: (handle: Collider) => boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): void;
	/**
	 * Casts a shape at a constant linear velocity and retrieve the first collider it hits.
	 * This is similar to ray-casting except that we are casting a whole shape instead of
	 * just a point (the ray origin).
	 *
	 * @param shapePos - The initial position of the shape to cast.
	 * @param shapeRot - The initial rotation of the shape to cast.
	 * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).
	 * @param shape - The shape to cast.
	 * @param targetDistance − If the shape moves closer to this distance from a collider, a hit
	 *                         will be returned.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.
	 * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if
	 *   the shape is penetrating another shape at its starting point **and** its trajectory is such
	 *   that it’s on a path to exit that penetration state.
	 * @param groups - The bit groups and filter associated to the shape to cast, in order to only
	 *   test on colliders with collision groups compatible with this group.
	 */
	castShape(shapePos: Vector, shapeRot: Rotation, shapeVel: Vector, shape: Shape, targetDistance: number, maxToi: number, stopAtPenetration: boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): ColliderShapeCastHit | null;
	/**
	 * Retrieve all the colliders intersecting the given shape.
	 *
	 * @param shapePos - The position of the shape to test.
	 * @param shapeRot - The orientation of the shape to test.
	 * @param shape - The shape to test.
	 * @param groups - The bit groups and filter associated to the shape to test, in order to only
	 *   test on colliders with collision groups compatible with this group.
	 * @param callback - A function called with the handles of each collider intersecting the `shape`.
	 */
	intersectionsWithShape(shapePos: Vector, shapeRot: Rotation, shape: Shape, callback: (collider: Collider) => boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: Collider, filterExcludeRigidBody?: RigidBody, filterPredicate?: (collider: Collider) => boolean): void;
	/**
	 * Finds the handles of all the colliders with an AABB intersecting the given AABB.
	 *
	 * @param aabbCenter - The center of the AABB to test.
	 * @param aabbHalfExtents - The half-extents of the AABB to test.
	 * @param callback - The callback that will be called with the handles of all the colliders
	 *                   currently intersecting the given AABB.
	 */
	collidersWithAabbIntersectingAabb(aabbCenter: Vector, aabbHalfExtents: Vector, callback: (handle: Collider) => boolean): void;
	/**
	 * Enumerates all the colliders potentially in contact with the given collider.
	 *
	 * @param collider1 - The second collider involved in the contact.
	 * @param f - Closure that will be called on each collider that is in contact with `collider1`.
	 */
	contactPairsWith(collider1: Collider, f: (collider2: Collider) => void): void;
	/**
	 * Enumerates all the colliders intersecting the given colliders, assuming one of them
	 * is a sensor.
	 */
	intersectionPairsWith(collider1: Collider, f: (collider2: Collider) => void): void;
	/**
	 * Iterates through all the contact manifolds between the given pair of colliders.
	 *
	 * @param collider1 - The first collider involved in the contact.
	 * @param collider2 - The second collider involved in the contact.
	 * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument
	 *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`
	 *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.
	 */
	contactPair(collider1: Collider, collider2: Collider, f: (manifold: TempContactManifold, flipped: boolean) => void): void;
	/**
	 * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.
	 * @param collider1 − The first collider involved in the intersection.
	 * @param collider2 − The second collider involved in the intersection.
	 */
	intersectionPair(collider1: Collider, collider2: Collider): boolean;
	/**
	 * Sets whether internal performance profiling is enabled (default: false).
	 *
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	set profilerEnabled(enabled: boolean);
	/**
	 * Indicates if the internal performance profiling is enabled.
	 *
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	get profilerEnabled(): boolean;
	/**
	 * The time spent in milliseconds by the last step to run the entire simulation step.
	 *
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingStep(): number;
	/**
	 * The time spent in milliseconds by the last step to run the collision-detection
	 * (broad-phase + narrow-phase).
	 *
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingCollisionDetection(): number;
	/**
	 * The time spent in milliseconds by the last step to run the broad-phase.
	 *
	 * This timing is included in `timingCollisionDetection`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingBroadPhase(): number;
	/**
	 * The time spent in milliseconds by the last step to run the narrow-phase.
	 *
	 * This timing is included in `timingCollisionDetection`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingNarrowPhase(): number;
	/**
	 * The time spent in milliseconds by the last step to run the constraint solver.
	 *
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingSolver(): number;
	/**
	 * The time spent in milliseconds by the last step to run the constraint
	 * initialization.
	 *
	 * This timing is included in `timingSolver`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingVelocityAssembly(): number;
	/**
	 * The time spent in milliseconds by the last step to run the constraint
	 * resolution.
	 *
	 * This timing is included in `timingSolver`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingVelocityResolution(): number;
	/**
	 * The time spent in milliseconds by the last step to run the rigid-body
	 * velocity update.
	 *
	 * This timing is included in `timingSolver`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingVelocityUpdate(): number;
	/**
	 * The time spent in milliseconds by writing rigid-body velocities
	 * calculated by the solver back into the rigid-bodies.
	 *
	 * This timing is included in `timingSolver`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingVelocityWriteback(): number;
	/**
	 * The total time spent in CCD detection and resolution.
	 *
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingCcd(): number;
	/**
	 * The total time spent searching for the continuous hits during CCD.
	 *
	 * This timing is included in `timingCcd`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingCcdToiComputation(): number;
	/**
	 * The total time spent in the broad-phase during CCD.
	 *
	 * This timing is included in `timingCcd`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingCcdBroadPhase(): number;
	/**
	 * The total time spent in the narrow-phase during CCD.
	 *
	 * This timing is included in `timingCcd`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingCcdNarrowPhase(): number;
	/**
	 * The total time spent in the constraints resolution during CCD.
	 *
	 * This timing is included in `timingCcd`.
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingCcdSolver(): number;
	/**
	 * The total time spent in the islands calculation during CCD.
	 *
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingIslandConstruction(): number;
	/**
	 * The total time spent propagating detected user changes.
	 *
	 * Only works if the internal profiler is enabled with `World.profilerEnabled = true`.
	 */
	timingUserChanges(): number;
}
/**
 * Pairwise filtering using bit masks.
 *
 * This filtering method is based on two 16-bit values:
 * - The interaction groups (the 16 left-most bits of `self.0`).
 * - The interaction mask (the 16 right-most bits of `self.0`).
 *
 * An interaction is allowed between two filters `a` and `b` two conditions
 * are met simultaneously:
 * - The interaction groups of `a` has at least one bit set to `1` in common with the interaction mask of `b`.
 * - The interaction groups of `b` has at least one bit set to `1` in common with the interaction mask of `a`.
 * In other words, interactions are allowed between two filter iff. the following condition is met:
 *
 * ```
 * ((a >> 16) & b) != 0 && ((b >> 16) & a) != 0
 * ```
 */
type InteractionGroups = number;
class ShapeContact {
	/**
	 * Distance between the two contact points.
	 * If this is negative, this contact represents a penetration.
	 */
	distance: number;
	/**
	 * Position of the contact on the first shape.
	 */
	point1: Vector;
	/**
	 * Position of the contact on the second shape.
	 */
	point2: Vector;
	/**
	 * Contact normal, pointing towards the exterior of the first shape.
	 */
	normal1: Vector;
	/**
	 * Contact normal, pointing towards the exterior of the second shape.
	 * If these contact data are expressed in world-space, this normal is equal to -normal1.
	 */
	normal2: Vector;
	constructor(dist: number, point1: Vector, point2: Vector, normal1: Vector, normal2: Vector);
	static fromRaw(raw: RawShapeContact): ShapeContact;
}
enum FeatureType {
	Vertex = 0,
	Face = 1,
	Unknown = 2
}
class PointProjection {
	/**
	 * The projection of the point on the collider.
	 */
	point: Vector;
	/**
	 * Is the point inside of the collider?
	 */
	isInside: boolean;
	constructor(point: Vector, isInside: boolean);
	static fromRaw(raw: RawPointProjection): PointProjection;
}
class PointColliderProjection {
	/**
	 * The collider hit by the ray.
	 */
	collider: Collider;
	/**
	 * The projection of the point on the collider.
	 */
	point: Vector;
	/**
	 * Is the point inside of the collider?
	 */
	isInside: boolean;
	/**
	 * The type of the geometric feature the point was projected on.
	 */
	featureType: FeatureType;
	/**
	 * The id of the geometric feature the point was projected on.
	 */
	featureId: number | undefined;
	constructor(collider: Collider, point: Vector, isInside: boolean, featureType?: FeatureType, featureId?: number);
	static fromRaw(colliderSet: ColliderSet, raw: RawPointColliderProjection): PointColliderProjection;
}
class Ray {
	/**
	 * The starting point of the ray.
	 */
	origin: Vector;
	/**
	 * The direction of propagation of the ray.
	 */
	dir: Vector;
	/**
	 * Builds a ray from its origin and direction.
	 *
	 * @param origin - The ray's starting point.
	 * @param dir - The ray's direction of propagation.
	 */
	constructor(origin: Vector, dir: Vector);
	pointAt(t: number): Vector;
}
class RayIntersection {
	/**
	 * The time-of-impact of the ray with the collider.
	 *
	 * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.
	 */
	timeOfImpact: number;
	/**
	 * The normal of the collider at the hit point.
	 */
	normal: Vector;
	/**
	 * The type of the geometric feature the point was projected on.
	 */
	featureType: FeatureType;
	/**
	 * The id of the geometric feature the point was projected on.
	 */
	featureId: number | undefined;
	constructor(timeOfImpact: number, normal: Vector, featureType?: FeatureType, featureId?: number);
	static fromRaw(raw: RawRayIntersection): RayIntersection;
}
class RayColliderIntersection {
	/**
	 * The collider hit by the ray.
	 */
	collider: Collider;
	/**
	 * The time-of-impact of the ray with the collider.
	 *
	 * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.
	 */
	timeOfImpact: number;
	/**
	 * The normal of the collider at the hit point.
	 */
	normal: Vector;
	/**
	 * The type of the geometric feature the point was projected on.
	 */
	featureType: FeatureType;
	/**
	 * The id of the geometric feature the point was projected on.
	 */
	featureId: number | undefined;
	constructor(collider: Collider, timeOfImpact: number, normal: Vector, featureType?: FeatureType, featureId?: number);
	static fromRaw(colliderSet: ColliderSet, raw: RawRayColliderIntersection): RayColliderIntersection;
}
class RayColliderHit {
	/**
	 * The handle of the collider hit by the ray.
	 */
	collider: Collider;
	/**
	 * The time-of-impact of the ray with the collider.
	 *
	 * The hit point is obtained from the ray's origin and direction: `origin + dir * timeOfImpact`.
	 */
	timeOfImpact: number;
	constructor(collider: Collider, timeOfImpact: number);
	static fromRaw(colliderSet: ColliderSet, raw: RawRayColliderHit): RayColliderHit;
}
class ShapeCastHit {
	/**
	 * The time of impact of the two shapes.
	 */
	time_of_impact: number;
	/**
	 * The local-space contact point on the first shape, at
	 * the time of impact.
	 */
	witness1: Vector;
	/**
	 * The local-space contact point on the second shape, at
	 * the time of impact.
	 */
	witness2: Vector;
	/**
	 * The local-space normal on the first shape, at
	 * the time of impact.
	 */
	normal1: Vector;
	/**
	 * The local-space normal on the second shape, at
	 * the time of impact.
	 */
	normal2: Vector;
	constructor(time_of_impact: number, witness1: Vector, witness2: Vector, normal1: Vector, normal2: Vector);
	static fromRaw(colliderSet: ColliderSet, raw: RawShapeCastHit): ShapeCastHit;
}
class ColliderShapeCastHit extends ShapeCastHit {
	/**
	 * The handle of the collider hit by the ray.
	 */
	collider: Collider;
	constructor(collider: Collider, time_of_impact: number, witness1: Vector, witness2: Vector, normal1: Vector, normal2: Vector);
	static fromRaw(colliderSet: ColliderSet, raw: RawColliderShapeCastHit): ColliderShapeCastHit;
}
abstract class Shape {
	abstract intoRaw(): RawShape;
	/**
	 * The concrete type of this shape.
	 */
	abstract get type(): ShapeType;
	/**
	 * instant mode without cache
	 */
	static fromRaw(rawSet: RawColliderSet, handle: ColliderHandle): Shape;
	/**
	 * Computes the time of impact between two moving shapes.
	 * @param shapePos1 - The initial position of this sahpe.
	 * @param shapeRot1 - The rotation of this shape.
	 * @param shapeVel1 - The velocity of this shape.
	 * @param shape2 - The second moving shape.
	 * @param shapePos2 - The initial position of the second shape.
	 * @param shapeRot2 - The rotation of the second shape.
	 * @param shapeVel2 - The velocity of the second shape.
	 * @param targetDistance − If the shape moves closer to this distance from a collider, a hit
	 *                         will be returned.
	 * @param maxToi - The maximum time when the impact can happen.
	 * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if
	 *   the shape is penetrating another shape at its starting point **and** its trajectory is such
	 *   that it’s on a path to exit that penetration state.
	 * @returns If the two moving shapes collider at some point along their trajectories, this returns the
	 *  time at which the two shape collider as well as the contact information during the impact. Returns
	 *  `null`if the two shapes never collide along their paths.
	 */
	castShape(shapePos1: Vector, shapeRot1: Rotation, shapeVel1: Vector, shape2: Shape, shapePos2: Vector, shapeRot2: Rotation, shapeVel2: Vector, targetDistance: number, maxToi: number, stopAtPenetration: boolean): ShapeCastHit | null;
	/**
	 * Tests if this shape intersects another shape.
	 *
	 * @param shapePos1 - The position of this shape.
	 * @param shapeRot1 - The rotation of this shape.
	 * @param shape2  - The second shape to test.
	 * @param shapePos2 - The position of the second shape.
	 * @param shapeRot2 - The rotation of the second shape.
	 * @returns `true` if the two shapes intersect, `false` if they don’t.
	 */
	intersectsShape(shapePos1: Vector, shapeRot1: Rotation, shape2: Shape, shapePos2: Vector, shapeRot2: Rotation): boolean;
	/**
	 * Computes one pair of contact points between two shapes.
	 *
	 * @param shapePos1 - The initial position of this sahpe.
	 * @param shapeRot1 - The rotation of this shape.
	 * @param shape2 - The second shape.
	 * @param shapePos2 - The initial position of the second shape.
	 * @param shapeRot2 - The rotation of the second shape.
	 * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.
	 * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.
	 */
	contactShape(shapePos1: Vector, shapeRot1: Rotation, shape2: Shape, shapePos2: Vector, shapeRot2: Rotation, prediction: number): ShapeContact | null;
	containsPoint(shapePos: Vector, shapeRot: Rotation, point: Vector): boolean;
	projectPoint(shapePos: Vector, shapeRot: Rotation, point: Vector, solid: boolean): PointProjection;
	intersectsRay(ray: Ray, shapePos: Vector, shapeRot: Rotation, maxToi: number): boolean;
	castRay(ray: Ray, shapePos: Vector, shapeRot: Rotation, maxToi: number, solid: boolean): number;
	castRayAndGetNormal(ray: Ray, shapePos: Vector, shapeRot: Rotation, maxToi: number, solid: boolean): RayIntersection;
}
enum ShapeType {
	Ball = 0,
	Cuboid = 1,
	Capsule = 2,
	Segment = 3,
	Polyline = 4,
	Triangle = 5,
	TriMesh = 6,
	HeightField = 7,
	ConvexPolygon = 9,
	RoundCuboid = 10,
	RoundTriangle = 11,
	RoundConvexPolygon = 12,
	HalfSpace = 13,
	Voxels = 14
}
enum TriMeshFlags {
	/**
	 * If set, any triangle that results in a failing half-hedge topology computation will be deleted.
	 */
	DELETE_BAD_TOPOLOGY_TRIANGLES = 4,
	/**
	 * If set, the trimesh will be assumed to be oriented (with outward normals).
	 *
	 * The pseudo-normals of its vertices and edges will be computed.
	 */
	ORIENTED = 8,
	/**
	 * If set, the duplicate vertices of the trimesh will be merged.
	 *
	 * Two vertices with the exact same coordinates will share the same entry on the
	 * vertex buffer and the index buffer is adjusted accordingly.
	 */
	MERGE_DUPLICATE_VERTICES = 16,
	/**
	 * If set, the triangles sharing two vertices with identical index values will be removed.
	 *
	 * Because of the way it is currently implemented, this methods implies that duplicate
	 * vertices will be merged. It will no longer be the case in the future once we decouple
	 * the computations.
	 */
	DELETE_DEGENERATE_TRIANGLES = 32,
	/**
	 * If set, two triangles sharing three vertices with identical index values (in any order)
	 * will be removed.
	 *
	 * Because of the way it is currently implemented, this methods implies that duplicate
	 * vertices will be merged. It will no longer be the case in the future once we decouple
	 * the computations.
	 */
	DELETE_DUPLICATE_TRIANGLES = 64,
	/**
	 * If set, a special treatment will be applied to contact manifold calculation to eliminate
	 * or fix contacts normals that could lead to incorrect bumps in physics simulation
	 * (especially on flat surfaces).
	 *
	 * This is achieved by taking into account adjacent triangle normals when computing contact
	 * points for a given triangle.
	 *
	 * /!\ NOT SUPPORTED IN THE 2D VERSION OF RAPIER.
	 */
	FIX_INTERNAL_EDGES = 144
}
enum ActiveCollisionTypes {
	/**
	 * Enable collision-detection between a collider attached to a dynamic body
	 * and another collider attached to a dynamic body.
	 */
	DYNAMIC_DYNAMIC = 1,
	/**
	 * Enable collision-detection between a collider attached to a dynamic body
	 * and another collider attached to a kinematic body.
	 */
	DYNAMIC_KINEMATIC = 12,
	/**
	 * Enable collision-detection between a collider attached to a dynamic body
	 * and another collider attached to a fixed body (or not attached to any body).
	 */
	DYNAMIC_FIXED = 2,
	/**
	 * Enable collision-detection between a collider attached to a kinematic body
	 * and another collider attached to a kinematic body.
	 */
	KINEMATIC_KINEMATIC = 52224,
	/**
	 * Enable collision-detection between a collider attached to a kinematic body
	 * and another collider attached to a fixed body (or not attached to any body).
	 */
	KINEMATIC_FIXED = 8704,
	/**
	 * Enable collision-detection between a collider attached to a fixed body (or
	 * not attached to any body) and another collider attached to a fixed body (or
	 * not attached to any body).
	 */
	FIXED_FIXED = 32,
	/**
	 * The default active collision types, enabling collisions between a dynamic body
	 * and another body of any type, but not enabling collisions between two non-dynamic bodies.
	 */
	DEFAULT = 15,
	/**
	 * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).
	 */
	ALL = 60943
}
/**
 * The integer identifier of a collider added to a `ColliderSet`.
 */
type ColliderHandle = number;
class Collider {
	private colliderSet;
	readonly handle: ColliderHandle;
	private _shape;
	private _parent;
	constructor(colliderSet: ColliderSet, handle: ColliderHandle, parent: RigidBody | null, shape?: Shape);
	/** @internal */
	finalizeDeserialization(bodies: RigidBodySet): void;
	private ensureShapeIsCached;
	/**
	 * The shape of this collider.
	 */
	get shape(): Shape;
	/**
	 * Set the internal cached JS shape to null.
	 *
	 * This can be useful if you want to free some memory (assuming you are not
	 * holding any other references to the shape object), or in order to force
	 * the recalculation of the JS shape (the next time the `shape` getter is
	 * accessed) from the WASM source of truth.
	 */
	clearShapeCache(): void;
	/**
	 * Checks if this collider is still valid (i.e. that it has
	 * not been deleted from the collider set yet).
	 */
	isValid(): boolean;
	/**
	 * The world-space translation of this collider.
	 */
	translation(): Vector;
	/**
	 * The translation of this collider relative to its parent rigid-body.
	 *
	 * Returns `null` if the collider doesn’t have a parent rigid-body.
	 */
	translationWrtParent(): Vector | null;
	/**
	 * The world-space orientation of this collider.
	 */
	rotation(): Rotation;
	/**
	 * The orientation of this collider relative to its parent rigid-body.
	 *
	 * Returns `null` if the collider doesn’t have a parent rigid-body.
	 */
	rotationWrtParent(): Rotation | null;
	/**
	 * Is this collider a sensor?
	 */
	isSensor(): boolean;
	/**
	 * Sets whether this collider is a sensor.
	 * @param isSensor - If `true`, the collider will be a sensor.
	 */
	setSensor(isSensor: boolean): void;
	/**
	 * Sets the new shape of the collider.
	 * @param shape - The collider’s new shape.
	 */
	setShape(shape: Shape): void;
	/**
	 * Sets whether this collider is enabled or not.
	 *
	 * @param enabled - Set to `false` to disable this collider (its parent rigid-body won’t be disabled automatically by this).
	 */
	setEnabled(enabled: boolean): void;
	/**
	 * Is this collider enabled?
	 */
	isEnabled(): boolean;
	/**
	 * Sets the restitution coefficient of the collider to be created.
	 *
	 * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior
	 *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the
	 *                   constraints solver).
	 */
	setRestitution(restitution: number): void;
	/**
	 * Sets the friction coefficient of the collider to be created.
	 *
	 * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The
	 *                   higher the coefficient, the stronger friction forces will be for contacts with the collider
	 *                   being built.
	 */
	setFriction(friction: number): void;
	/**
	 * Gets the rule used to combine the friction coefficients of two colliders
	 * colliders involved in a contact.
	 */
	frictionCombineRule(): CoefficientCombineRule;
	/**
	 * Sets the rule used to combine the friction coefficients of two colliders
	 * colliders involved in a contact.
	 *
	 * @param rule − The combine rule to apply.
	 */
	setFrictionCombineRule(rule: CoefficientCombineRule): void;
	/**
	 * Gets the rule used to combine the restitution coefficients of two colliders
	 * colliders involved in a contact.
	 */
	restitutionCombineRule(): CoefficientCombineRule;
	/**
	 * Sets the rule used to combine the restitution coefficients of two colliders
	 * colliders involved in a contact.
	 *
	 * @param rule − The combine rule to apply.
	 */
	setRestitutionCombineRule(rule: CoefficientCombineRule): void;
	/**
	 * Sets the collision groups used by this collider.
	 *
	 * Two colliders will interact iff. their collision groups are compatible.
	 * See the documentation of `InteractionGroups` for details on teh used bit pattern.
	 *
	 * @param groups - The collision groups used for the collider being built.
	 */
	setCollisionGroups(groups: InteractionGroups): void;
	/**
	 * Sets the solver groups used by this collider.
	 *
	 * Forces between two colliders in contact will be computed iff their solver
	 * groups are compatible.
	 * See the documentation of `InteractionGroups` for details on the used bit pattern.
	 *
	 * @param groups - The solver groups used for the collider being built.
	 */
	setSolverGroups(groups: InteractionGroups): void;
	/**
	 * Sets the contact skin for this collider.
	 *
	 * See the documentation of `ColliderDesc.setContactSkin` for additional details.
	 */
	contactSkin(): number;
	/**
	 * Sets the contact skin for this collider.
	 *
	 * See the documentation of `ColliderDesc.setContactSkin` for additional details.
	 *
	 * @param thickness - The contact skin thickness.
	 */
	setContactSkin(thickness: number): void;
	/**
	 * Get the physics hooks active for this collider.
	 */
	activeHooks(): ActiveHooks;
	/**
	 * Set the physics hooks active for this collider.
	 *
	 * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.
	 *
	 * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.
	 */
	setActiveHooks(activeHooks: ActiveHooks): void;
	/**
	 * The events active for this collider.
	 */
	activeEvents(): ActiveEvents;
	/**
	 * Set the events active for this collider.
	 *
	 * Use this to enable contact and/or intersection event reporting for this collider.
	 *
	 * @param activeEvents - The events active for contact/intersection pairs involving this collider.
	 */
	setActiveEvents(activeEvents: ActiveEvents): void;
	/**
	 * Gets the collision types active for this collider.
	 */
	activeCollisionTypes(): ActiveCollisionTypes;
	/**
	 * Sets the total force magnitude beyond which a contact force event can be emitted.
	 *
	 * @param threshold - The new force threshold.
	 */
	setContactForceEventThreshold(threshold: number): void;
	/**
	 * The total force magnitude beyond which a contact force event can be emitted.
	 */
	contactForceEventThreshold(): number;
	/**
	 * Set the collision types active for this collider.
	 *
	 * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.
	 */
	setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes): void;
	/**
	 * Sets the uniform density of this collider.
	 *
	 * This will override any previous mass-properties set by `this.setDensity`,
	 * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,
	 * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.
	 *
	 * The mass and angular inertia of this collider will be computed automatically based on its
	 * shape.
	 */
	setDensity(density: number): void;
	/**
	 * Sets the mass of this collider.
	 *
	 * This will override any previous mass-properties set by `this.setDensity`,
	 * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,
	 * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.
	 *
	 * The angular inertia of this collider will be computed automatically based on its shape
	 * and this mass value.
	 */
	setMass(mass: number): void;
	/**
	 * Sets the mass of this collider.
	 *
	 * This will override any previous mass-properties set by `this.setDensity`,
	 * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,
	 * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.
	 */
	setMassProperties(mass: number, centerOfMass: Vector, principalAngularInertia: number): void;
	/**
	 * Sets the translation of this collider.
	 *
	 * @param tra - The world-space position of the collider.
	 */
	setTranslation(tra: Vector): void;
	/**
	 * Sets the translation of this collider relative to its parent rigid-body.
	 *
	 * Does nothing if this collider isn't attached to a rigid-body.
	 *
	 * @param tra - The new translation of the collider relative to its parent.
	 */
	setTranslationWrtParent(tra: Vector): void;
	/**
	 * Sets the rotation angle of this collider.
	 *
	 * @param angle - The rotation angle, in radians.
	 */
	setRotation(angle: number): void;
	/**
	 * Sets the rotation angle of this collider relative to its parent rigid-body.
	 *
	 * Does nothing if this collider isn't attached to a rigid-body.
	 *
	 * @param angle - The rotation angle, in radians.
	 */
	setRotationWrtParent(angle: number): void;
	/**
	 * The type of the shape of this collider.
	 */
	shapeType(): ShapeType;
	/**
	 * The half-extents of this collider if it is a cuboid shape.
	 */
	halfExtents(): Vector;
	/**
	 * Sets the half-extents of this collider if it is a cuboid shape.
	 *
	 * @param newHalfExtents - desired half extents.
	 */
	setHalfExtents(newHalfExtents: Vector): void;
	/**
	 * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.
	 */
	radius(): number;
	/**
	 * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.
	 *
	 * @param newRadius - desired radius.
	 */
	setRadius(newRadius: number): void;
	/**
	 * The radius of the round edges of this collider if it is a round cylinder.
	 */
	roundRadius(): number;
	/**
	 * Sets the radius of the round edges of this collider if it has round edges.
	 *
	 * @param newBorderRadius - desired round edge radius.
	 */
	setRoundRadius(newBorderRadius: number): void;
	/**
	 * The half height of this collider if it is a cylinder, capsule, or cone shape.
	 */
	halfHeight(): number;
	/**
	 * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.
	 *
	 * @param newHalfheight - desired half height.
	 */
	setHalfHeight(newHalfheight: number): void;
	/**
	 * If this collider has a Voxels shape, this will mark the voxel at the
	 * given grid coordinates as filled or empty (depending on the `filled`
	 * argument).
	 *
	 * Each input value is assumed to be an integer.
	 *
	 * The operation is O(1), unless the provided coordinates are out of the
	 * bounds of the currently allocated internal grid in which case the grid
	 * will be grown automatically.
	 */
	setVoxel(ix: number, iy: number, filled: boolean): void;
	/**
	 * If this and `voxels2` are voxel colliders, and a voxel from `this` was
	 * modified with `setVoxel`, this will ensure that a
	 * moving object transitioning across the boundaries of these colliders
	 * won’t suffer from the "internal edges" artifact.
	 *
	 * The indices `ix, iy, iz` indicate the integer coordinates of the voxel in
	 * the local coordinate frame of `this`.
	 *
	 * If the voxels in `voxels2` live in a different coordinate space from `this`,
	 * then the `shift_*` argument indicate the distance, in voxel units, between
	 * the origin of `this` to the origin of `voxels2`.
	 *
	 * This method is intended to be called between `this` and all the other
	 * voxels colliders with a domain intersecting `this` or sharing a domain
	 * boundary. This is an incremental maintenance of the effect of
	 * `combineVoxelStates`.
	 */
	propagateVoxelChange(voxels2: Collider, ix: number, iy: number, shift_x: number, shift_y: number): void;
	/**
	 * If this and `voxels2` are voxel colliders, this will ensure that a
	 * moving object transitioning across the boundaries of these colliders
	 * won’t suffer from the "internal edges" artifact.
	 *
	 * If the voxels in `voxels2` live in a different coordinate space from `this`,
	 * then the `shift_*` argument indicate the distance, in voxel units, between
	 * the origin of `this` to the origin of `voxels2`.
	 *
	 * This method is intended to be called once between all pairs of voxels
	 * colliders with intersecting domains or shared boundaries.
	 *
	 * If either voxels collider is then modified with `setVoxel`, the
	 * `propagateVoxelChange` method must be called to maintain the coupling
	 * between the voxels shapes after the modification.
	 */
	combineVoxelStates(voxels2: Collider, shift_x: number, shift_y: number): void;
	/**
	 * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,
	 * this returns the vertex buffer of said shape.
	 */
	vertices(): Float32Array;
	/**
	 * If this collider has a triangle mesh, polyline, or convex polyhedron shape,
	 * this returns the index buffer of said shape.
	 */
	indices(): Uint32Array | undefined;
	/**
	 * If this collider has a heightfield shape, this returns the heights buffer of
	 * the heightfield.
	 * In 3D, the returned height matrix is provided in column-major order.
	 */
	heightfieldHeights(): Float32Array;
	/**
	 * If this collider has a heightfield shape, this returns the scale
	 * applied to it.
	 */
	heightfieldScale(): Vector;
	/**
	 * The rigid-body this collider is attached to.
	 */
	parent(): RigidBody | null;
	/**
	 * The friction coefficient of this collider.
	 */
	friction(): number;
	/**
	 * The restitution coefficient of this collider.
	 */
	restitution(): number;
	/**
	 * The density of this collider.
	 */
	density(): number;
	/**
	 * The mass of this collider.
	 */
	mass(): number;
	/**
	 * The volume of this collider.
	 */
	volume(): number;
	/**
	 * The collision groups of this collider.
	 */
	collisionGroups(): InteractionGroups;
	/**
	 * The solver groups of this collider.
	 */
	solverGroups(): InteractionGroups;
	/**
	 * Tests if this collider contains a point.
	 *
	 * @param point - The point to test.
	 */
	containsPoint(point: Vector): boolean;
	/**
	 * Find the projection of a point on this collider.
	 *
	 * @param point - The point to project.
	 * @param solid - If this is set to `true` then the collider shapes are considered to
	 *   be plain (if the point is located inside of a plain shape, its projection is the point
	 *   itself). If it is set to `false` the collider shapes are considered to be hollow
	 *   (if the point is located inside of an hollow shape, it is projected on the shape's
	 *   boundary).
	 */
	projectPoint(point: Vector, solid: boolean): PointProjection | null;
	/**
	 * Tests if this collider intersects the given ray.
	 *
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 */
	intersectsRay(ray: Ray, maxToi: number): boolean;
	castShape(collider1Vel: Vector, shape2: Shape, shape2Pos: Vector, shape2Rot: Rotation, shape2Vel: Vector, targetDistance: number, maxToi: number, stopAtPenetration: boolean): ShapeCastHit | null;
	castCollider(collider1Vel: Vector, collider2: Collider, collider2Vel: Vector, targetDistance: number, maxToi: number, stopAtPenetration: boolean): ColliderShapeCastHit | null;
	intersectsShape(shape2: Shape, shapePos2: Vector, shapeRot2: Rotation): boolean;
	/**
	 * Computes one pair of contact points between the shape owned by this collider and the given shape.
	 *
	 * @param shape2 - The second shape.
	 * @param shape2Pos - The initial position of the second shape.
	 * @param shape2Rot - The rotation of the second shape.
	 * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.
	 * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.
	 */
	contactShape(shape2: Shape, shape2Pos: Vector, shape2Rot: Rotation, prediction: number): ShapeContact | null;
	/**
	 * Computes one pair of contact points between the collider and the given collider.
	 *
	 * @param collider2 - The second collider.
	 * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.
	 * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.
	 */
	contactCollider(collider2: Collider, prediction: number): ShapeContact | null;
	/**
	 * Find the closest intersection between a ray and this collider.
	 *
	 * This also computes the normal at the hit point.
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
	 *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
	 *   whereas `false` implies that all shapes are hollow for this ray-cast.
	 * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.
	 */
	castRay(ray: Ray, maxToi: number, solid: boolean): number;
	/**
	 * Find the closest intersection between a ray and this collider.
	 *
	 * This also computes the normal at the hit point.
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
	 *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
	 *   whereas `false` implies that all shapes are hollow for this ray-cast.
	 */
	castRayAndGetNormal(ray: Ray, maxToi: number, solid: boolean): RayIntersection | null;
}
enum MassPropsMode {
	Density = 0,
	Mass = 1,
	MassProps = 2
}
class ColliderDesc {
	enabled: boolean;
	shape: Shape;
	massPropsMode: MassPropsMode;
	mass: number;
	centerOfMass: Vector;
	principalAngularInertia: number;
	rotationsEnabled: boolean;
	density: number;
	friction: number;
	restitution: number;
	rotation: Rotation;
	translation: Vector;
	isSensor: boolean;
	collisionGroups: InteractionGroups;
	solverGroups: InteractionGroups;
	frictionCombineRule: CoefficientCombineRule;
	restitutionCombineRule: CoefficientCombineRule;
	activeEvents: ActiveEvents;
	activeHooks: ActiveHooks;
	activeCollisionTypes: ActiveCollisionTypes;
	contactForceEventThreshold: number;
	contactSkin: number;
	/**
	 * Initializes a collider descriptor from the collision shape.
	 *
	 * @param shape - The shape of the collider being built.
	 */
	constructor(shape: Shape);
	/**
	 * Create a new collider descriptor with a ball shape.
	 *
	 * @param radius - The radius of the ball.
	 */
	static ball(radius: number): ColliderDesc;
	/**
	 * Create a new collider descriptor with a capsule shape.
	 *
	 * @param halfHeight - The half-height of the capsule, along the `y` axis.
	 * @param radius - The radius of the capsule basis.
	 */
	static capsule(halfHeight: number, radius: number): ColliderDesc;
	/**
	 * Creates a new segment shape.
	 *
	 * @param a - The first point of the segment.
	 * @param b - The second point of the segment.
	 */
	static segment(a: Vector, b: Vector): ColliderDesc;
	/**
	 * Creates a new triangle shape.
	 *
	 * @param a - The first point of the triangle.
	 * @param b - The second point of the triangle.
	 * @param c - The third point of the triangle.
	 */
	static triangle(a: Vector, b: Vector, c: Vector): ColliderDesc;
	/**
	 * Creates a new triangle shape with round corners.
	 *
	 * @param a - The first point of the triangle.
	 * @param b - The second point of the triangle.
	 * @param c - The third point of the triangle.
	 * @param borderRadius - The radius of the borders of this triangle. In 3D,
	 *   this is also equal to half the thickness of the triangle.
	 */
	static roundTriangle(a: Vector, b: Vector, c: Vector, borderRadius: number): ColliderDesc;
	/**
	 * Creates a new collider descriptor with a polyline shape.
	 *
	 * @param vertices - The coordinates of the polyline's vertices.
	 * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,
	 *    the vertices are assumed to describe a line strip.
	 */
	static polyline(vertices: Float32Array, indices?: Uint32Array | null): ColliderDesc;
	/**
	 * Creates a new collider descriptor with a shape made of voxels.
	 *
	 * @param data - Defines the set of voxels. If this is a `Int32Array` then
	 *               each voxel is defined from its (signed) grid coordinates,
	 *               with 3 (resp 2) contiguous integers per voxel in 3D (resp 2D).
	 *               If this is a `Float32Array`, each voxel will be such that
	 *               they contain at least one point from this array (where each
	 *               point is defined from 3 (resp 2) contiguous numbers per point
	 *               in 3D (resp 2D).
	 * @param voxelSize - The size of each voxel.
	 */
	static voxels(voxels: Float32Array | Int32Array, voxelSize: Vector): ColliderDesc;
	/**
	 * Creates a new collider descriptor with a triangle mesh shape.
	 *
	 * @param vertices - The coordinates of the triangle mesh's vertices.
	 * @param indices - The indices of the triangle mesh's triangles.
	 */
	static trimesh(vertices: Float32Array, indices: Uint32Array, flags?: TriMeshFlags): ColliderDesc;
	/**
	 * Creates a new collider descriptor with a rectangular shape.
	 *
	 * @param hx - The half-width of the rectangle along its local `x` axis.
	 * @param hy - The half-width of the rectangle along its local `y` axis.
	 */
	static cuboid(hx: number, hy: number): ColliderDesc;
	/**
	 * Creates a new collider descriptor with a rectangular shape with round borders.
	 *
	 * @param hx - The half-width of the rectangle along its local `x` axis.
	 * @param hy - The half-width of the rectangle along its local `y` axis.
	 * @param borderRadius - The radius of the cuboid's borders.
	 */
	static roundCuboid(hx: number, hy: number, borderRadius: number): ColliderDesc;
	/**
	 * Creates a new collider description with a halfspace (infinite plane) shape.
	 *
	 * @param normal - The outward normal of the plane.
	 */
	static halfspace(normal: Vector): ColliderDesc;
	/**
	 * Creates a new collider descriptor with a heightfield shape.
	 *
	 * @param heights - The heights of the heightfield, along its local `y` axis.
	 * @param scale - The scale factor applied to the heightfield.
	 */
	static heightfield(heights: Float32Array, scale: Vector): ColliderDesc;
	/**
	 * Computes the convex-hull of the given points and use the resulting
	 * convex polygon as the shape for this new collider descriptor.
	 *
	 * @param points - The point that will be used to compute the convex-hull.
	 */
	static convexHull(points: Float32Array): ColliderDesc | null;
	/**
	 * Creates a new collider descriptor that uses the given set of points assumed
	 * to form a convex polyline (no convex-hull computation will be done).
	 *
	 * @param vertices - The vertices of the convex polyline.
	 */
	static convexPolyline(vertices: Float32Array): ColliderDesc | null;
	/**
	 * Computes the convex-hull of the given points and use the resulting
	 * convex polygon as the shape for this new collider descriptor. A
	 * border is added to that convex polygon to give it round corners.
	 *
	 * @param points - The point that will be used to compute the convex-hull.
	 * @param borderRadius - The radius of the round border added to the convex polygon.
	 */
	static roundConvexHull(points: Float32Array, borderRadius: number): ColliderDesc | null;
	/**
	 * Creates a new collider descriptor that uses the given set of points assumed
	 * to form a round convex polyline (no convex-hull computation will be done).
	 *
	 * @param vertices - The vertices of the convex polyline.
	 * @param borderRadius - The radius of the round border added to the convex polyline.
	 */
	static roundConvexPolyline(vertices: Float32Array, borderRadius: number): ColliderDesc | null;
	/**
	 * Sets the position of the collider to be created relative to the rigid-body it is attached to.
	 */
	setTranslation(x: number, y: number): ColliderDesc;
	/**
	 * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.
	 *
	 * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.
	 */
	setRotation(rot: Rotation): ColliderDesc;
	/**
	 * Sets whether or not the collider being created is a sensor.
	 *
	 * A sensor collider does not take part of the physics simulation, but generates
	 * proximity events.
	 *
	 * @param sensor - Set to `true` of the collider built is to be a sensor.
	 */
	setSensor(sensor: boolean): ColliderDesc;
	/**
	 * Sets whether the created collider will be enabled or disabled.
	 * @param enabled − If set to `false` the collider will be disabled at creation.
	 */
	setEnabled(enabled: boolean): ColliderDesc;
	/**
	 * Sets the contact skin of the collider.
	 *
	 * The contact skin acts as if the collider was enlarged with a skin of width `skin_thickness`
	 * around it, keeping objects further apart when colliding.
	 *
	 * A non-zero contact skin can increase performance, and in some cases, stability. However
	 * it creates a small gap between colliding object (equal to the sum of their skin). If the
	 * skin is sufficiently small, this might not be visually significant or can be hidden by the
	 * rendering assets.
	 */
	setContactSkin(thickness: number): ColliderDesc;
	/**
	 * Sets the density of the collider being built.
	 *
	 * The mass and angular inertia tensor will be computed automatically based on this density and the collider’s shape.
	 *
	 * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider
	 *                  will not affect the mass or angular inertia of the rigid-body it is attached to.
	 */
	setDensity(density: number): ColliderDesc;
	/**
	 * Sets the mass of the collider being built.
	 *
	 * The angular inertia tensor will be computed automatically based on this mass and the collider’s shape.
	 *
	 * @param mass - The mass to set, must be greater or equal to 0.
	 */
	setMass(mass: number): ColliderDesc;
	/**
	 * Sets the mass properties of the collider being built.
	 *
	 * This replaces the mass-properties automatically computed from the collider's density and shape.
	 * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.
	 *
	 * @param mass − The mass of the collider to create.
	 * @param centerOfMass − The center-of-mass of the collider to create.
	 * @param principalAngularInertia − The principal angular inertia of the collider to create.
	 */
	setMassProperties(mass: number, centerOfMass: Vector, principalAngularInertia: number): ColliderDesc;
	/**
	 * Sets the restitution coefficient of the collider to be created.
	 *
	 * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior
	 *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the
	 *                   constraints solver).
	 */
	setRestitution(restitution: number): ColliderDesc;
	/**
	 * Sets the friction coefficient of the collider to be created.
	 *
	 * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The
	 *                   higher the coefficient, the stronger friction forces will be for contacts with the collider
	 *                   being built.
	 */
	setFriction(friction: number): ColliderDesc;
	/**
	 * Sets the rule used to combine the friction coefficients of two colliders
	 * colliders involved in a contact.
	 *
	 * @param rule − The combine rule to apply.
	 */
	setFrictionCombineRule(rule: CoefficientCombineRule): ColliderDesc;
	/**
	 * Sets the rule used to combine the restitution coefficients of two colliders
	 * colliders involved in a contact.
	 *
	 * @param rule − The combine rule to apply.
	 */
	setRestitutionCombineRule(rule: CoefficientCombineRule): ColliderDesc;
	/**
	 * Sets the collision groups used by this collider.
	 *
	 * Two colliders will interact iff. their collision groups are compatible.
	 * See the documentation of `InteractionGroups` for details on teh used bit pattern.
	 *
	 * @param groups - The collision groups used for the collider being built.
	 */
	setCollisionGroups(groups: InteractionGroups): ColliderDesc;
	/**
	 * Sets the solver groups used by this collider.
	 *
	 * Forces between two colliders in contact will be computed iff their solver
	 * groups are compatible.
	 * See the documentation of `InteractionGroups` for details on the used bit pattern.
	 *
	 * @param groups - The solver groups used for the collider being built.
	 */
	setSolverGroups(groups: InteractionGroups): ColliderDesc;
	/**
	 * Set the physics hooks active for this collider.
	 *
	 * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.
	 *
	 * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.
	 */
	setActiveHooks(activeHooks: ActiveHooks): ColliderDesc;
	/**
	 * Set the events active for this collider.
	 *
	 * Use this to enable contact and/or intersection event reporting for this collider.
	 *
	 * @param activeEvents - The events active for contact/intersection pairs involving this collider.
	 */
	setActiveEvents(activeEvents: ActiveEvents): ColliderDesc;
	/**
	 * Set the collision types active for this collider.
	 *
	 * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.
	 */
	setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes): ColliderDesc;
	/**
	 * Sets the total force magnitude beyond which a contact force event can be emitted.
	 *
	 * @param threshold - The force threshold to set.
	 */
	setContactForceEventThreshold(threshold: number): ColliderDesc;
}
class ColliderSet {
	raw: RawColliderSet;
	private map;
	/**
	 * Release the WASM memory occupied by this collider set.
	 */
	free(): void;
	constructor(raw?: RawColliderSet);
	/** @internal */
	castClosure<Res>(f?: (collider: Collider) => Res): (handle: ColliderHandle) => Res | undefined;
	/** @internal */
	finalizeDeserialization(bodies: RigidBodySet): void;
	/**
	 * Creates a new collider and return its integer handle.
	 *
	 * @param bodies - The set of bodies where the collider's parent can be found.
	 * @param desc - The collider's description.
	 * @param parentHandle - The integer handle of the rigid-body this collider is attached to.
	 */
	createCollider(bodies: RigidBodySet, desc: ColliderDesc, parentHandle: RigidBodyHandle): Collider;
	/**
	 * Remove a collider from this set.
	 *
	 * @param handle - The integer handle of the collider to remove.
	 * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.
	 * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.
	 */
	remove(handle: ColliderHandle, islands: IslandManager, bodies: RigidBodySet, wakeUp: boolean): void;
	/**
	 * Internal function, do not call directly.
	 * @param handle
	 */
	unmap(handle: ImpulseJointHandle): void;
	/**
	 * Gets the rigid-body with the given handle.
	 *
	 * @param handle - The handle of the rigid-body to retrieve.
	 */
	get(handle: ColliderHandle): Collider | null;
	/**
	 * The number of colliders on this set.
	 */
	len(): number;
	/**
	 * Does this set contain a collider with the given handle?
	 *
	 * @param handle - The collider handle to check.
	 */
	contains(handle: ColliderHandle): boolean;
	/**
	 * Applies the given closure to each collider contained by this set.
	 *
	 * @param f - The closure to apply.
	 */
	forEach(f: (collider: Collider) => void): void;
	/**
	 * Gets all colliders in the list.
	 *
	 * @returns collider list.
	 */
	getAll(): Collider[];
}
class NarrowPhase {
	raw: RawNarrowPhase;
	tempManifold: TempContactManifold;
	/**
	 * Release the WASM memory occupied by this narrow-phase.
	 */
	free(): void;
	constructor(raw?: RawNarrowPhase);
	/**
	 * Enumerates all the colliders potentially in contact with the given collider.
	 *
	 * @param collider1 - The second collider involved in the contact.
	 * @param f - Closure that will be called on each collider that is in contact with `collider1`.
	 */
	contactPairsWith(collider1: ColliderHandle, f: (collider2: ColliderHandle) => void): void;
	/**
	 * Enumerates all the colliders intersecting the given colliders, assuming one of them
	 * is a sensor.
	 */
	intersectionPairsWith(collider1: ColliderHandle, f: (collider2: ColliderHandle) => void): void;
	/**
	 * Iterates through all the contact manifolds between the given pair of colliders.
	 *
	 * @param collider1 - The first collider involved in the contact.
	 * @param collider2 - The second collider involved in the contact.
	 * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument
	 *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`
	 *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.
	 */
	contactPair(collider1: ColliderHandle, collider2: ColliderHandle, f: (manifold: TempContactManifold, flipped: boolean) => void): void;
	/**
	 * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.
	 * @param collider1 − The first collider involved in the intersection.
	 * @param collider2 − The second collider involved in the intersection.
	 */
	intersectionPair(collider1: ColliderHandle, collider2: ColliderHandle): boolean;
}
class TempContactManifold {
	raw: RawContactManifold;
	free(): void;
	constructor(raw: RawContactManifold);
	normal(): Vector;
	localNormal1(): Vector;
	localNormal2(): Vector;
	subshape1(): number;
	subshape2(): number;
	numContacts(): number;
	localContactPoint1(i: number): Vector | null;
	localContactPoint2(i: number): Vector | null;
	contactDist(i: number): number;
	contactFid1(i: number): number;
	contactFid2(i: number): number;
	contactImpulse(i: number): number;
	contactTangentImpulse(i: number): number;
	numSolverContacts(): number;
	solverContactPoint(i: number): Vector;
	solverContactDist(i: number): number;
	solverContactFriction(i: number): number;
	solverContactRestitution(i: number): number;
	solverContactTangentVelocity(i: number): Vector;
}
class BroadPhase {
	raw: RawBroadPhase;
	/**
	 * Release the WASM memory occupied by this broad-phase.
	 */
	free(): void;
	constructor(raw?: RawBroadPhase);
	/**
	 * Find the closest intersection between a ray and a set of collider.
	 *
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
	 *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
	 *   whereas `false` implies that all shapes are hollow for this ray-cast.
	 * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
	 * @param filter - The callback to filter out which collider will be hit.
	 */
	castRay(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, ray: Ray, maxToi: number, solid: boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): RayColliderHit | null;
	/**
	 * Find the closest intersection between a ray and a set of collider.
	 *
	 * This also computes the normal at the hit point.
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
	 *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
	 *   whereas `false` implies that all shapes are hollow for this ray-cast.
	 * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
	 */
	castRayAndGetNormal(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, ray: Ray, maxToi: number, solid: boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): RayColliderIntersection | null;
	/**
	 * Cast a ray and collects all the intersections between a ray and the scene.
	 *
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param ray - The ray to cast.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the length of the ray to `ray.dir.norm() * maxToi`.
	 * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its
	 *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,
	 *   whereas `false` implies that all shapes are hollow for this ray-cast.
	 * @param groups - Used to filter the colliders that can or cannot be hit by the ray.
	 * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.
	 *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.
	 */
	intersectionsWithRay(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, ray: Ray, maxToi: number, solid: boolean, callback: (intersect: RayColliderIntersection) => boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): void;
	/**
	 * Gets the handle of up to one collider intersecting the given shape.
	 *
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param shapePos - The position of the shape used for the intersection test.
	 * @param shapeRot - The orientation of the shape used for the intersection test.
	 * @param shape - The shape used for the intersection test.
	 * @param groups - The bit groups and filter associated to the ray, in order to only
	 *   hit the colliders with collision groups compatible with the ray's group.
	 */
	intersectionWithShape(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, shapePos: Vector, shapeRot: Rotation, shape: Shape, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): ColliderHandle | null;
	/**
	 * Find the projection of a point on the closest collider.
	 *
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param point - The point to project.
	 * @param solid - If this is set to `true` then the collider shapes are considered to
	 *   be plain (if the point is located inside of a plain shape, its projection is the point
	 *   itself). If it is set to `false` the collider shapes are considered to be hollow
	 *   (if the point is located inside of an hollow shape, it is projected on the shape's
	 *   boundary).
	 * @param groups - The bit groups and filter associated to the point to project, in order to only
	 *   project on colliders with collision groups compatible with the ray's group.
	 */
	projectPoint(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, point: Vector, solid: boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): PointColliderProjection | null;
	/**
	 * Find the projection of a point on the closest collider.
	 *
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param point - The point to project.
	 * @param groups - The bit groups and filter associated to the point to project, in order to only
	 *   project on colliders with collision groups compatible with the ray's group.
	 */
	projectPointAndGetFeature(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, point: Vector, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): PointColliderProjection | null;
	/**
	 * Find all the colliders containing the given point.
	 *
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param point - The point used for the containment test.
	 * @param groups - The bit groups and filter associated to the point to test, in order to only
	 *   test on colliders with collision groups compatible with the ray's group.
	 * @param callback - A function called with the handles of each collider with a shape
	 *   containing the `point`.
	 */
	intersectionsWithPoint(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, point: Vector, callback: (handle: ColliderHandle) => boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): void;
	/**
	 * Casts a shape at a constant linear velocity and retrieve the first collider it hits.
	 * This is similar to ray-casting except that we are casting a whole shape instead of
	 * just a point (the ray origin).
	 *
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param shapePos - The initial position of the shape to cast.
	 * @param shapeRot - The initial rotation of the shape to cast.
	 * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).
	 * @param shape - The shape to cast.
	 * @param targetDistance − If the shape moves closer to this distance from a collider, a hit
	 *                       will be returned.
	 * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively
	 *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.
	 * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if
	 *   the shape is penetrating another shape at its starting point **and** its trajectory is such
	 *   that it’s on a path to exit that penetration state.
	 * @param groups - The bit groups and filter associated to the shape to cast, in order to only
	 *   test on colliders with collision groups compatible with this group.
	 */
	castShape(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, shapePos: Vector, shapeRot: Rotation, shapeVel: Vector, shape: Shape, targetDistance: number, maxToi: number, stopAtPenetration: boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): ColliderShapeCastHit | null;
	/**
	 * Retrieve all the colliders intersecting the given shape.
	 *
	 * @param colliders - The set of colliders taking part in this pipeline.
	 * @param shapePos - The position of the shape to test.
	 * @param shapeRot - The orientation of the shape to test.
	 * @param shape - The shape to test.
	 * @param groups - The bit groups and filter associated to the shape to test, in order to only
	 *   test on colliders with collision groups compatible with this group.
	 * @param callback - A function called with the handles of each collider intersecting the `shape`.
	 */
	intersectionsWithShape(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, shapePos: Vector, shapeRot: Rotation, shape: Shape, callback: (handle: ColliderHandle) => boolean, filterFlags?: QueryFilterFlags, filterGroups?: InteractionGroups, filterExcludeCollider?: ColliderHandle, filterExcludeRigidBody?: RigidBodyHandle, filterPredicate?: (collider: ColliderHandle) => boolean): void;
	/**
	 * Finds the handles of all the colliders with an AABB intersecting the given AABB.
	 *
	 * @param aabbCenter - The center of the AABB to test.
	 * @param aabbHalfExtents - The half-extents of the AABB to test.
	 * @param callback - The callback that will be called with the handles of all the colliders
	 *                   currently intersecting the given AABB.
	 */
	collidersWithAabbIntersectingAabb(narrowPhase: NarrowPhase, bodies: RigidBodySet, colliders: ColliderSet, aabbCenter: Vector, aabbHalfExtents: Vector, callback: (handle: ColliderHandle) => boolean): void;
}
/**
 * The integer identifier of a collider added to a `ColliderSet`.
 */
type RigidBodyHandle = number;
enum RigidBodyType {
	/**
	 * A `RigidBodyType::Dynamic` body can be affected by all external forces.
	 */
	Dynamic = 0,
	/**
	 * A `RigidBodyType::Fixed` body cannot be affected by external forces.
	 */
	Fixed = 1,
	/**
	 * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled
	 * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.
	 *
	 * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body
	 * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be
	 * modified by the user and is independent from any contact or joint it is involved in.
	 */
	KinematicPositionBased = 2,
	/**
	 * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled
	 * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.
	 *
	 * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body
	 * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be
	 * modified by the user and is independent from any contact or joint it is involved in.
	 */
	KinematicVelocityBased = 3
}
class RigidBody {
	private rawSet;
	private colliderSet;
	readonly handle: RigidBodyHandle;
	/**
	 * An arbitrary user-defined object associated with this rigid-body.
	 */
	userData?: unknown;
	constructor(rawSet: RawRigidBodySet, colliderSet: ColliderSet, handle: RigidBodyHandle);
	/** @internal */
	finalizeDeserialization(colliderSet: ColliderSet): void;
	/**
	 * Checks if this rigid-body is still valid (i.e. that it has
	 * not been deleted from the rigid-body set yet.
	 */
	isValid(): boolean;
	/**
	 * Locks or unlocks the ability of this rigid-body to translate.
	 *
	 * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.
	 * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.
	 */
	lockTranslations(locked: boolean, wakeUp: boolean): void;
	/**
	 * Locks or unlocks the ability of this rigid-body to rotate.
	 *
	 * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.
	 * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.
	 */
	lockRotations(locked: boolean, wakeUp: boolean): void;
	/**
	 * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.
	 *
	 * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.
	 * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.
	 * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.
	 */
	setEnabledTranslations(enableX: boolean, enableY: boolean, wakeUp: boolean): void;
	/**
	 * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.
	 *
	 * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.
	 * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.
	 * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.
	 * @deprecated use `this.setEnabledTranslations` with the same arguments instead.
	 */
	restrictTranslations(enableX: boolean, enableY: boolean, wakeUp: boolean): void;
	/**
	 * The dominance group, in [-127, +127] this rigid-body is part of.
	 */
	dominanceGroup(): number;
	/**
	 * Sets the dominance group of this rigid-body.
	 *
	 * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].
	 */
	setDominanceGroup(group: number): void;
	/**
	 * The number of additional solver iterations that will be run for this
	 * rigid-body and everything that interacts with it directly or indirectly
	 * through contacts or joints.
	 */
	additionalSolverIterations(): number;
	/**
	 * Sets the number of additional solver iterations that will be run for this
	 * rigid-body and everything that interacts with it directly or indirectly
	 * through contacts or joints.
	 *
	 * Compared to increasing the global `World.numSolverIteration`, setting this
	 * value lets you increase accuracy on only a subset of the scene, resulting in reduced
	 * performance loss.
	 *
	 * @param iters - The new number of additional solver iterations (default: 0).
	 */
	setAdditionalSolverIterations(iters: number): void;
	/**
	 * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.
	 *
	 * @param enabled - If `true`, CCD will be enabled for this rigid-body.
	 */
	enableCcd(enabled: boolean): void;
	/**
	 * Sets the soft-CCD prediction distance for this rigid-body.
	 *
	 * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for
	 * additional details.
	 */
	setSoftCcdPrediction(distance: number): void;
	/**
	 * Gets the soft-CCD prediction distance for this rigid-body.
	 *
	 * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for
	 * additional details.
	 */
	softCcdPrediction(): number;
	/**
	 * The world-space translation of this rigid-body.
	 */
	translation(): Vector;
	/**
	 * The world-space orientation of this rigid-body.
	 */
	rotation(): Rotation;
	/**
	 * The world-space next translation of this rigid-body.
	 *
	 * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`
	 * method and is used for estimating the kinematic body velocity at the next timestep.
	 * For non-kinematic bodies, this value is currently unspecified.
	 */
	nextTranslation(): Vector;
	/**
	 * The world-space next orientation of this rigid-body.
	 *
	 * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`
	 * method and is used for estimating the kinematic body velocity at the next timestep.
	 * For non-kinematic bodies, this value is currently unspecified.
	 */
	nextRotation(): Rotation;
	/**
	 * Sets the translation of this rigid-body.
	 *
	 * @param tra - The world-space position of the rigid-body.
	 * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it
	 *                 wasn't moving before modifying its position.
	 */
	setTranslation(tra: Vector, wakeUp: boolean): void;
	/**
	 * Sets the linear velocity of this rigid-body.
	 *
	 * @param vel - The linear velocity to set.
	 * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.
	 */
	setLinvel(vel: Vector, wakeUp: boolean): void;
	/**
	 * The scale factor applied to the gravity affecting
	 * this rigid-body.
	 */
	gravityScale(): number;
	/**
	 * Sets the scale factor applied to the gravity affecting
	 * this rigid-body.
	 *
	 * @param factor - The scale factor to set. A value of 0.0 means
	 *   that this rigid-body will on longer be affected by gravity.
	 * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.
	 */
	setGravityScale(factor: number, wakeUp: boolean): void;
	/**
	 * Sets the rotation angle of this rigid-body.
	 *
	 * @param angle - The rotation angle, in radians.
	 * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it
	 * wasn't moving before modifying its position.
	 */
	setRotation(angle: number, wakeUp: boolean): void;
	/**
	 * Sets the angular velocity fo this rigid-body.
	 *
	 * @param vel - The angular velocity to set.
	 * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.
	 */
	setAngvel(vel: number, wakeUp: boolean): void;
	/**
	 * If this rigid body is kinematic, sets its future translation after the next timestep integration.
	 *
	 * This should be used instead of `rigidBody.setTranslation` to make the dynamic object
	 * interacting with this kinematic body behave as expected. Internally, Rapier will compute
	 * an artificial velocity for this rigid-body from its current position and its next kinematic
	 * position. This velocity will be used to compute forces on dynamic bodies interacting with
	 * this body.
	 *
	 * @param t - The kinematic translation to set.
	 */
	setNextKinematicTranslation(t: Vector): void;
	/**
	 * If this rigid body is kinematic, sets its future rotation after the next timestep integration.
	 *
	 * This should be used instead of `rigidBody.setRotation` to make the dynamic object
	 * interacting with this kinematic body behave as expected. Internally, Rapier will compute
	 * an artificial velocity for this rigid-body from its current position and its next kinematic
	 * position. This velocity will be used to compute forces on dynamic bodies interacting with
	 * this body.
	 *
	 * @param angle - The kinematic rotation angle, in radians.
	 */
	setNextKinematicRotation(angle: number): void;
	/**
	 * The linear velocity of this rigid-body.
	 */
	linvel(): Vector;
	/**
	 * The velocity of the given world-space point on this rigid-body.
	 */
	velocityAtPoint(point: Vector): Vector;
	/**
	 * The angular velocity of this rigid-body.
	 */
	angvel(): number;
	/**
	 * The mass of this rigid-body.
	 */
	mass(): number;
	/**
	 * The inverse mass taking into account translation locking.
	 */
	effectiveInvMass(): Vector;
	/**
	 * The inverse of the mass of a rigid-body.
	 *
	 * If this is zero, the rigid-body is assumed to have infinite mass.
	 */
	invMass(): number;
	/**
	 * The center of mass of a rigid-body expressed in its local-space.
	 */
	localCom(): Vector;
	/**
	 * The world-space center of mass of the rigid-body.
	 */
	worldCom(): Vector;
	/**
	 * The inverse of the principal angular inertia of the rigid-body.
	 *
	 * Components set to zero are assumed to be infinite along the corresponding principal axis.
	 */
	invPrincipalInertia(): number;
	/**
	 * The angular inertia along the principal inertia axes of the rigid-body.
	 */
	principalInertia(): number;
	/**
	 * The world-space inverse angular inertia tensor of the rigid-body,
	 * taking into account rotation locking.
	 */
	effectiveWorldInvInertia(): number;
	/**
	 * The effective world-space angular inertia (that takes the potential rotation locking into account) of
	 * this rigid-body.
	 */
	effectiveAngularInertia(): number;
	/**
	 * Put this rigid body to sleep.
	 *
	 * A sleeping body no longer moves and is no longer simulated by the physics engine unless
	 * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to
	 * external forces like contacts.
	 */
	sleep(): void;
	/**
	 * Wakes this rigid-body up.
	 *
	 * A dynamic rigid-body that does not move during several consecutive frames will
	 * be put to sleep by the physics engine, i.e., it will stop being simulated in order
	 * to avoid useless computations.
	 * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying
	 * the position of a dynamic body so that it is properly simulated afterwards.
	 */
	wakeUp(): void;
	/**
	 * Is CCD enabled for this rigid-body?
	 */
	isCcdEnabled(): boolean;
	/**
	 * The number of colliders attached to this rigid-body.
	 */
	numColliders(): number;
	/**
	 * Retrieves the `i-th` collider attached to this rigid-body.
	 *
	 * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.
	 *         This index is **not** the same as the unique identifier of the collider.
	 */
	collider(i: number): Collider;
	/**
	 * Sets whether this rigid-body is enabled or not.
	 *
	 * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.
	 */
	setEnabled(enabled: boolean): void;
	/**
	 * Is this rigid-body enabled?
	 */
	isEnabled(): boolean;
	/**
	 * The status of this rigid-body: static, dynamic, or kinematic.
	 */
	bodyType(): RigidBodyType;
	/**
	 * Set a new status for this rigid-body: static, dynamic, or kinematic.
	 */
	setBodyType(type: RigidBodyType, wakeUp: boolean): void;
	/**
	 * Is this rigid-body sleeping?
	 */
	isSleeping(): boolean;
	/**
	 * Is the velocity of this rigid-body not zero?
	 */
	isMoving(): boolean;
	/**
	 * Is this rigid-body static?
	 */
	isFixed(): boolean;
	/**
	 * Is this rigid-body kinematic?
	 */
	isKinematic(): boolean;
	/**
	 * Is this rigid-body dynamic?
	 */
	isDynamic(): boolean;
	/**
	 * The linear damping coefficient of this rigid-body.
	 */
	linearDamping(): number;
	/**
	 * The angular damping coefficient of this rigid-body.
	 */
	angularDamping(): number;
	/**
	 * Sets the linear damping factor applied to this rigid-body.
	 *
	 * @param factor - The damping factor to set.
	 */
	setLinearDamping(factor: number): void;
	/**
	 * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.
	 */
	recomputeMassPropertiesFromColliders(): void;
	/**
	 * Sets the rigid-body's additional mass.
	 *
	 * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this
	 * scaling effect isn’t desired, use Self::additional_mass_properties instead of this method.
	 *
	 * This is only the "additional" mass because the total mass of the rigid-body is equal to the sum of this
	 * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.
	 *
	 * That total mass (which includes the attached colliders’ contributions) will be updated at the name physics step,
	 * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.
	 *
	 * This will override any previous additional mass-properties set by `this.setAdditionalMass`,
	 * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or
	 * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.
	 *
	 * @param mass - The additional mass to set.
	 * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.
	 */
	setAdditionalMass(mass: number, wakeUp: boolean): void;
	/**
	 * Sets the rigid-body's additional mass-properties.
	 *
	 * This is only the "additional" mass-properties because the total mass-properties of the rigid-body is equal to the
	 * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached
	 * to this rigid-body.
	 *
	 * That total mass-properties (which include the attached colliders’ contributions) will be updated at the name
	 * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.
	 *
	 * This will override any previous mass-properties set by `this.setAdditionalMass`,
	 * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`
	 * for this rigid-body.
	 *
	 * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.
	 */
	setAdditionalMassProperties(mass: number, centerOfMass: Vector, principalAngularInertia: number, wakeUp: boolean): void;
	/**
	 * Sets the linear damping factor applied to this rigid-body.
	 *
	 * @param factor - The damping factor to set.
	 */
	setAngularDamping(factor: number): void;
	/**
	 * Resets to zero the user forces (but not torques) applied to this rigid-body.
	 *
	 * @param wakeUp - should the rigid-body be automatically woken-up?
	 */
	resetForces(wakeUp: boolean): void;
	/**
	 * Resets to zero the user torques applied to this rigid-body.
	 *
	 * @param wakeUp - should the rigid-body be automatically woken-up?
	 */
	resetTorques(wakeUp: boolean): void;
	/**
	 * Adds a force at the center-of-mass of this rigid-body.
	 *
	 * @param force - the world-space force to add to the rigid-body.
	 * @param wakeUp - should the rigid-body be automatically woken-up?
	 */
	addForce(force: Vector, wakeUp: boolean): void;
	/**
	 * Applies an impulse at the center-of-mass of this rigid-body.
	 *
	 * @param impulse - the world-space impulse to apply on the rigid-body.
	 * @param wakeUp - should the rigid-body be automatically woken-up?
	 */
	applyImpulse(impulse: Vector, wakeUp: boolean): void;
	/**
	 * Adds a torque at the center-of-mass of this rigid-body.
	 *
	 * @param torque - the torque to add to the rigid-body.
	 * @param wakeUp - should the rigid-body be automatically woken-up?
	 */
	addTorque(torque: number, wakeUp: boolean): void;
	/**
	 * Applies an impulsive torque at the center-of-mass of this rigid-body.
	 *
	 * @param torqueImpulse - the torque impulse to apply on the rigid-body.
	 * @param wakeUp - should the rigid-body be automatically woken-up?
	 */
	applyTorqueImpulse(torqueImpulse: number, wakeUp: boolean): void;
	/**
	 * Adds a force at the given world-space point of this rigid-body.
	 *
	 * @param force - the world-space force to add to the rigid-body.
	 * @param point - the world-space point where the impulse is to be applied on the rigid-body.
	 * @param wakeUp - should the rigid-body be automatically woken-up?
	 */
	addForceAtPoint(force: Vector, point: Vector, wakeUp: boolean): void;
	/**
	 * Applies an impulse at the given world-space point of this rigid-body.
	 *
	 * @param impulse - the world-space impulse to apply on the rigid-body.
	 * @param point - the world-space point where the impulse is to be applied on the rigid-body.
	 * @param wakeUp - should the rigid-body be automatically woken-up?
	 */
	applyImpulseAtPoint(impulse: Vector, point: Vector, wakeUp: boolean): void;
	/**
	 * Retrieves the constant force(s) the user added to this rigid-body
	 * Returns zero if the rigid-body is not dynamic.
	 */
	userForce(): Vector;
	/**
	 * Retrieves the constant torque(s) the user added to this rigid-body
	 * Returns zero if the rigid-body is not dynamic.
	 */
	userTorque(): number;
}
class RigidBodyDesc {
	enabled: boolean;
	translation: Vector;
	rotation: Rotation;
	gravityScale: number;
	mass: number;
	massOnly: boolean;
	centerOfMass: Vector;
	translationsEnabledX: boolean;
	translationsEnabledY: boolean;
	linvel: Vector;
	angvel: number;
	principalAngularInertia: number;
	rotationsEnabled: boolean;
	linearDamping: number;
	angularDamping: number;
	status: RigidBodyType;
	canSleep: boolean;
	sleeping: boolean;
	ccdEnabled: boolean;
	softCcdPrediction: number;
	dominanceGroup: number;
	additionalSolverIterations: number;
	userData?: unknown;
	constructor(status: RigidBodyType);
	/**
	 * A rigid-body descriptor used to build a dynamic rigid-body.
	 */
	static dynamic(): RigidBodyDesc;
	/**
	 * A rigid-body descriptor used to build a position-based kinematic rigid-body.
	 */
	static kinematicPositionBased(): RigidBodyDesc;
	/**
	 * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.
	 */
	static kinematicVelocityBased(): RigidBodyDesc;
	/**
	 * A rigid-body descriptor used to build a fixed rigid-body.
	 */
	static fixed(): RigidBodyDesc;
	/**
	 * A rigid-body descriptor used to build a dynamic rigid-body.
	 *
	 * @deprecated The method has been renamed to `.dynamic()`.
	 */
	static newDynamic(): RigidBodyDesc;
	/**
	 * A rigid-body descriptor used to build a position-based kinematic rigid-body.
	 *
	 * @deprecated The method has been renamed to `.kinematicPositionBased()`.
	 */
	static newKinematicPositionBased(): RigidBodyDesc;
	/**
	 * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.
	 *
	 * @deprecated The method has been renamed to `.kinematicVelocityBased()`.
	 */
	static newKinematicVelocityBased(): RigidBodyDesc;
	/**
	 * A rigid-body descriptor used to build a fixed rigid-body.
	 *
	 * @deprecated The method has been renamed to `.fixed()`.
	 */
	static newStatic(): RigidBodyDesc;
	setDominanceGroup(group: number): RigidBodyDesc;
	/**
	 * Sets the number of additional solver iterations that will be run for this
	 * rigid-body and everything that interacts with it directly or indirectly
	 * through contacts or joints.
	 *
	 * Compared to increasing the global `World.numSolverIteration`, setting this
	 * value lets you increase accuracy on only a subset of the scene, resulting in reduced
	 * performance loss.
	 *
	 * @param iters - The new number of additional solver iterations (default: 0).
	 */
	setAdditionalSolverIterations(iters: number): RigidBodyDesc;
	/**
	 * Sets whether the created rigid-body will be enabled or disabled.
	 * @param enabled − If set to `false` the rigid-body will be disabled at creation.
	 */
	setEnabled(enabled: boolean): RigidBodyDesc;
	/**
	 * Sets the initial translation of the rigid-body to create.
	 */
	setTranslation(x: number, y: number): RigidBodyDesc;
	/**
	 * Sets the initial rotation of the rigid-body to create.
	 *
	 * @param rot - The rotation to set.
	 */
	setRotation(rot: Rotation): RigidBodyDesc;
	/**
	 * Sets the scale factor applied to the gravity affecting
	 * the rigid-body being built.
	 *
	 * @param scale - The scale factor. Set this to `0.0` if the rigid-body
	 *   needs to ignore gravity.
	 */
	setGravityScale(scale: number): RigidBodyDesc;
	/**
	 * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.
	 *
	 * @param mass − The initial mass of the rigid-body to create.
	 */
	setAdditionalMass(mass: number): RigidBodyDesc;
	/**
	 * Sets the initial linear velocity of the rigid-body to create.
	 *
	 * @param x - The linear velocity to set along the `x` axis.
	 * @param y - The linear velocity to set along the `y` axis.
	 */
	setLinvel(x: number, y: number): RigidBodyDesc;
	/**
	 * Sets the initial angular velocity of the rigid-body to create.
	 *
	 * @param vel - The angular velocity to set.
	 */
	setAngvel(vel: number): RigidBodyDesc;
	/**
	 * Sets the mass properties of the rigid-body being built.
	 *
	 * Note that the final mass properties of the rigid-bodies depends
	 * on the initial mass-properties of the rigid-body (set by this method)
	 * to which is added the contributions of all the colliders with non-zero density
	 * attached to this rigid-body.
	 *
	 * Therefore, if you want your provided mass properties to be the final
	 * mass properties of your rigid-body, don't attach colliders to it, or
	 * only attach colliders with densities equal to zero.
	 *
	 * @param mass − The initial mass of the rigid-body to create.
	 * @param centerOfMass − The initial center-of-mass of the rigid-body to create.
	 * @param principalAngularInertia − The initial principal angular inertia of the rigid-body to create.
	 */
	setAdditionalMassProperties(mass: number, centerOfMass: Vector, principalAngularInertia: number): RigidBodyDesc;
	/**
	 * Allow translation of this rigid-body only along specific axes.
	 * @param translationsEnabledX - Are translations along the X axis enabled?
	 * @param translationsEnabledY - Are translations along the y axis enabled?
	 */
	enabledTranslations(translationsEnabledX: boolean, translationsEnabledY: boolean): RigidBodyDesc;
	/**
	 * Allow translation of this rigid-body only along specific axes.
	 * @param translationsEnabledX - Are translations along the X axis enabled?
	 * @param translationsEnabledY - Are translations along the y axis enabled?
	 * @deprecated use `this.enabledTranslations` with the same arguments instead.
	 */
	restrictTranslations(translationsEnabledX: boolean, translationsEnabledY: boolean): RigidBodyDesc;
	/**
	 * Locks all translations that would have resulted from forces on
	 * the created rigid-body.
	 */
	lockTranslations(): RigidBodyDesc;
	/**
	 * Locks all rotations that would have resulted from forces on
	 * the created rigid-body.
	 */
	lockRotations(): RigidBodyDesc;
	/**
	 * Sets the linear damping of the rigid-body to create.
	 *
	 * This will progressively slowdown the translational movement of the rigid-body.
	 *
	 * @param damping - The angular damping coefficient. Should be >= 0. The higher this
	 *                  value is, the stronger the translational slowdown will be.
	 */
	setLinearDamping(damping: number): RigidBodyDesc;
	/**
	 * Sets the angular damping of the rigid-body to create.
	 *
	 * This will progressively slowdown the rotational movement of the rigid-body.
	 *
	 * @param damping - The angular damping coefficient. Should be >= 0. The higher this
	 *                  value is, the stronger the rotational slowdown will be.
	 */
	setAngularDamping(damping: number): RigidBodyDesc;
	/**
	 * Sets whether or not the rigid-body to create can sleep.
	 *
	 * @param can - true if the rigid-body can sleep, false if it can't.
	 */
	setCanSleep(can: boolean): RigidBodyDesc;
	/**
	 * Sets whether or not the rigid-body is to be created asleep.
	 *
	 * @param can - true if the rigid-body should be in sleep, default false.
	 */
	setSleeping(sleeping: boolean): RigidBodyDesc;
	/**
	 * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.
	 *
	 * @param enabled - true if the rigid-body has CCD enabled.
	 */
	setCcdEnabled(enabled: boolean): RigidBodyDesc;
	/**
	 * Sets the maximum prediction distance Soft Continuous Collision-Detection.
	 *
	 * When set to 0, soft-CCD is disabled. Soft-CCD helps prevent tunneling especially of
	 * slow-but-thin to moderately fast objects. The soft CCD prediction distance indicates how
	 * far in the object’s path the CCD algorithm is allowed to inspect. Large values can impact
	 * performance badly by increasing the work needed from the broad-phase.
	 *
	 * It is a generally cheaper variant of regular CCD (that can be enabled with
	 * `RigidBodyDesc::setCcdEnabled` since it relies on predictive constraints instead of
	 * shape-cast and substeps.
	 */
	setSoftCcdPrediction(distance: number): RigidBodyDesc;
	/**
	 * Sets the user-defined object of this rigid-body.
	 *
	 * @param userData - The user-defined object to set.
	 */
	setUserData(data?: unknown): RigidBodyDesc;
}
/**
 * The integer identifier of a collider added to a `ColliderSet`.
 */
type ImpulseJointHandle = number;
enum JointType {
	Revolute = 0,
	Fixed = 1,
	Prismatic = 2,
	Rope = 3,
	Spring = 4
}
enum JointAxesMask {
	LinX = 1,
	LinY = 2,
	LinZ = 4,
	AngX = 8,
	AngY = 16,
	AngZ = 32
}
class ImpulseJoint {
	protected rawSet: RawImpulseJointSet;
	protected bodySet: RigidBodySet;
	handle: ImpulseJointHandle;
	constructor(rawSet: RawImpulseJointSet, bodySet: RigidBodySet, handle: ImpulseJointHandle);
	static newTyped(rawSet: RawImpulseJointSet, bodySet: RigidBodySet, handle: ImpulseJointHandle): ImpulseJoint;
	/** @internal */
	finalizeDeserialization(bodySet: RigidBodySet): void;
	/**
	 * Checks if this joint is still valid (i.e. that it has
	 * not been deleted from the joint set yet).
	 */
	isValid(): boolean;
	/**
	 * The first rigid-body this joint it attached to.
	 */
	body1(): RigidBody;
	/**
	 * The second rigid-body this joint is attached to.
	 */
	body2(): RigidBody;
	/**
	 * The type of this joint given as a string.
	 */
	type(): JointType;
	/**
	 * The position of the first anchor of this joint.
	 *
	 * The first anchor gives the position of the application point on the
	 * local frame of the first rigid-body it is attached to.
	 */
	anchor1(): Vector;
	/**
	 * The position of the second anchor of this joint.
	 *
	 * The second anchor gives the position of the application point on the
	 * local frame of the second rigid-body it is attached to.
	 */
	anchor2(): Vector;
	/**
	 * Sets the position of the first anchor of this joint.
	 *
	 * The first anchor gives the position of the application point on the
	 * local frame of the first rigid-body it is attached to.
	 */
	setAnchor1(newPos: Vector): void;
	/**
	 * Sets the position of the second anchor of this joint.
	 *
	 * The second anchor gives the position of the application point on the
	 * local frame of the second rigid-body it is attached to.
	 */
	setAnchor2(newPos: Vector): void;
	/**
	 * Controls whether contacts are computed between colliders attached
	 * to the rigid-bodies linked by this joint.
	 */
	setContactsEnabled(enabled: boolean): void;
	/**
	 * Indicates if contacts are enabled between colliders attached
	 * to the rigid-bodies linked by this joint.
	 */
	contactsEnabled(): boolean;
}
class JointData {
	anchor1: Vector;
	anchor2: Vector;
	axis: Vector;
	frame1: Rotation;
	frame2: Rotation;
	jointType: JointType;
	limitsEnabled: boolean;
	limits: Array<number>;
	axesMask: JointAxesMask;
	stiffness: number;
	damping: number;
	length: number;
	private constructor();
	/**
	 * Creates a new joint descriptor that builds a Fixed joint.
	 *
	 * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their
	 * anchor and local frames coincide in world-space.
	 *
	 * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
	 *                  local-space of the rigid-body.
	 * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.
	 * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
	 *                  local-space of the rigid-body.
	 * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.
	 */
	static fixed(anchor1: Vector, frame1: Rotation, anchor2: Vector, frame2: Rotation): JointData;
	static spring(rest_length: number, stiffness: number, damping: number, anchor1: Vector, anchor2: Vector): JointData;
	static rope(length: number, anchor1: Vector, anchor2: Vector): JointData;
	/**
	 * Create a new joint descriptor that builds revolute joints.
	 *
	 * A revolute joint allows three relative rotational degrees of freedom
	 * by preventing any relative translation between the anchors of the
	 * two attached rigid-bodies.
	 *
	 * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
	 *                  local-space of the rigid-body.
	 * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
	 *                  local-space of the rigid-body.
	 */
	static revolute(anchor1: Vector, anchor2: Vector): JointData;
	/**
	 * Creates a new joint descriptor that builds a Prismatic joint.
	 *
	 * A prismatic joint removes all the degrees of freedom between the
	 * affected bodies, except for the translation along one axis.
	 *
	 * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the
	 *                  local-space of the rigid-body.
	 * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the
	 *                  local-space of the rigid-body.
	 * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.
	 */
	static prismatic(anchor1: Vector, anchor2: Vector, axis: Vector): JointData;
	intoRaw(): RawGenericJoint;
}
class ImpulseJointSet {
	raw: RawImpulseJointSet;
	private map;
	/**
	 * Release the WASM memory occupied by this joint set.
	 */
	free(): void;
	constructor(raw?: RawImpulseJointSet);
	/** @internal */
	finalizeDeserialization(bodies: RigidBodySet): void;
	/**
	 * Creates a new joint and return its integer handle.
	 *
	 * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.
	 * @param desc - The joint's parameters.
	 * @param parent1 - The handle of the first rigid-body this joint is attached to.
	 * @param parent2 - The handle of the second rigid-body this joint is attached to.
	 * @param wakeUp - Should the attached rigid-bodies be awakened?
	 */
	createJoint(bodies: RigidBodySet, desc: JointData, parent1: RigidBodyHandle, parent2: RigidBodyHandle, wakeUp: boolean): ImpulseJoint;
	/**
	 * Remove a joint from this set.
	 *
	 * @param handle - The integer handle of the joint.
	 * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.
	 */
	remove(handle: ImpulseJointHandle, wakeUp: boolean): void;
	/**
	 * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.
	 *
	 * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.
	 */
	forEachJointHandleAttachedToRigidBody(handle: RigidBodyHandle, f: (handle: ImpulseJointHandle) => void): void;
	/**
	 * Internal function, do not call directly.
	 * @param handle
	 */
	unmap(handle: ImpulseJointHandle): void;
	/**
	 * The number of joints on this set.
	 */
	len(): number;
	/**
	 * Does this set contain a joint with the given handle?
	 *
	 * @param handle - The joint handle to check.
	 */
	contains(handle: ImpulseJointHandle): boolean;
	/**
	 * Gets the joint with the given handle.
	 *
	 * Returns `null` if no joint with the specified handle exists.
	 *
	 * @param handle - The integer handle of the joint to retrieve.
	 */
	get(handle: ImpulseJointHandle): ImpulseJoint | null;
	/**
	 * Applies the given closure to each joint contained by this set.
	 *
	 * @param f - The closure to apply.
	 */
	forEach(f: (joint: ImpulseJoint) => void): void;
	/**
	 * Gets all joints in the list.
	 *
	 * @returns joint list.
	 */
	getAll(): ImpulseJoint[];
}
/**
 * The integer identifier of a collider added to a `ColliderSet`.
 */
type MultibodyJointHandle = number;
class MultibodyJoint {
	protected rawSet: RawMultibodyJointSet;
	handle: MultibodyJointHandle;
	constructor(rawSet: RawMultibodyJointSet, handle: MultibodyJointHandle);
	static newTyped(rawSet: RawMultibodyJointSet, handle: MultibodyJointHandle): MultibodyJoint;
	/**
	 * Checks if this joint is still valid (i.e. that it has
	 * not been deleted from the joint set yet).
	 */
	isValid(): boolean;
	/**
	 * Controls whether contacts are computed between colliders attached
	 * to the rigid-bodies linked by this joint.
	 */
	setContactsEnabled(enabled: boolean): void;
	/**
	 * Indicates if contacts are enabled between colliders attached
	 * to the rigid-bodies linked by this joint.
	 */
	contactsEnabled(): boolean;
}
class MultibodyJointSet {
	raw: RawMultibodyJointSet;
	private map;
	/**
	 * Release the WASM memory occupied by this joint set.
	 */
	free(): void;
	constructor(raw?: RawMultibodyJointSet);
	/**
	 * Creates a new joint and return its integer handle.
	 *
	 * @param desc - The joint's parameters.
	 * @param parent1 - The handle of the first rigid-body this joint is attached to.
	 * @param parent2 - The handle of the second rigid-body this joint is attached to.
	 * @param wakeUp - Should the attached rigid-bodies be awakened?
	 */
	createJoint(desc: JointData, parent1: RigidBodyHandle, parent2: RigidBodyHandle, wakeUp: boolean): MultibodyJoint;
	/**
	 * Remove a joint from this set.
	 *
	 * @param handle - The integer handle of the joint.
	 * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.
	 */
	remove(handle: MultibodyJointHandle, wake_up: boolean): void;
	/**
	 * Internal function, do not call directly.
	 * @param handle
	 */
	unmap(handle: MultibodyJointHandle): void;
	/**
	 * The number of joints on this set.
	 */
	len(): number;
	/**
	 * Does this set contain a joint with the given handle?
	 *
	 * @param handle - The joint handle to check.
	 */
	contains(handle: MultibodyJointHandle): boolean;
	/**
	 * Gets the joint with the given handle.
	 *
	 * Returns `null` if no joint with the specified handle exists.
	 *
	 * @param handle - The integer handle of the joint to retrieve.
	 */
	get(handle: MultibodyJointHandle): MultibodyJoint | null;
	/**
	 * Applies the given closure to each joint contained by this set.
	 *
	 * @param f - The closure to apply.
	 */
	forEach(f: (joint: MultibodyJoint) => void): void;
	/**
	 * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.
	 *
	 * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.
	 */
	forEachJointHandleAttachedToRigidBody(handle: RigidBodyHandle, f: (handle: MultibodyJointHandle) => void): void;
	/**
	 * Gets all joints in the list.
	 *
	 * @returns joint list.
	 */
	getAll(): MultibodyJoint[];
}
class IslandManager {
	raw: RawIslandManager;
	/**
	 * Release the WASM memory occupied by this narrow-phase.
	 */
	free(): void;
	constructor(raw?: RawIslandManager);
	/**
	 * Applies the given closure to the handle of each active rigid-bodies contained by this set.
	 *
	 * A rigid-body is active if it is not sleeping, i.e., if it moved recently.
	 *
	 * @param f - The closure to apply.
	 */
	forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void): void;
}
class RigidBodySet {
	raw: RawRigidBodySet;
	private map;
	/**
	 * Release the WASM memory occupied by this rigid-body set.
	 */
	free(): void;
	constructor(raw?: RawRigidBodySet);
	/**
	 * Internal method, do not call this explicitly.
	 */
	finalizeDeserialization(colliderSet: ColliderSet): void;
	/**
	 * Creates a new rigid-body and return its integer handle.
	 *
	 * @param desc - The description of the rigid-body to create.
	 */
	createRigidBody(colliderSet: ColliderSet, desc: RigidBodyDesc): RigidBody;
	/**
	 * Removes a rigid-body from this set.
	 *
	 * This will also remove all the colliders and joints attached to the rigid-body.
	 *
	 * @param handle - The integer handle of the rigid-body to remove.
	 * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.
	 * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.
	 * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.
	 */
	remove(handle: RigidBodyHandle, islands: IslandManager, colliders: ColliderSet, impulseJoints: ImpulseJointSet, multibodyJoints: MultibodyJointSet): void;
	/**
	 * The number of rigid-bodies on this set.
	 */
	len(): number;
	/**
	 * Does this set contain a rigid-body with the given handle?
	 *
	 * @param handle - The rigid-body handle to check.
	 */
	contains(handle: RigidBodyHandle): boolean;
	/**
	 * Gets the rigid-body with the given handle.
	 *
	 * @param handle - The handle of the rigid-body to retrieve.
	 */
	get(handle: RigidBodyHandle): RigidBody | null;
	/**
	 * Applies the given closure to each rigid-body contained by this set.
	 *
	 * @param f - The closure to apply.
	 */
	forEach(f: (body: RigidBody) => void): void;
	/**
	 * Applies the given closure to each active rigid-bodies contained by this set.
	 *
	 * A rigid-body is active if it is not sleeping, i.e., if it moved recently.
	 *
	 * @param f - The closure to apply.
	 */
	forEachActiveRigidBody(islands: IslandManager, f: (body: RigidBody) => void): void;
	/**
	 * Gets all rigid-bodies in the list.
	 *
	 * @returns rigid-bodies list.
	 */
	getAll(): RigidBody[];
}
class IntegrationParameters {
	raw: RawIntegrationParameters;
	constructor(raw?: RawIntegrationParameters);
	/**
	 * Free the WASM memory used by these integration parameters.
	 */
	free(): void;
	/**
	 * The timestep length (default: `1.0 / 60.0`)
	 */
	get dt(): number;
	/**
	 * The Error Reduction Parameter in `[0, 1]` is the proportion of
	 * the positional error to be corrected at each time step (default: `0.2`).
	 */
	get contact_erp(): number;
	get lengthUnit(): number;
	/**
	 * Normalized amount of penetration the engine won’t attempt to correct (default: `0.001m`).
	 *
	 * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.
	 */
	get normalizedAllowedLinearError(): number;
	/**
	 * The maximal normalized distance separating two objects that will generate predictive contacts (default: `0.002`).
	 *
	 * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.
	 */
	get normalizedPredictionDistance(): number;
	/**
	 * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).
	 */
	get numSolverIterations(): number;
	/**
	 * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).
	 */
	get numInternalPgsIterations(): number;
	/**
	 * Minimum number of dynamic bodies in each active island (default: `128`).
	 */
	get minIslandSize(): number;
	/**
	 * Maximum number of substeps performed by the  solver (default: `1`).
	 */
	get maxCcdSubsteps(): number;
	set dt(value: number);
	set contact_natural_frequency(value: number);
	set lengthUnit(value: number);
	set normalizedAllowedLinearError(value: number);
	set normalizedPredictionDistance(value: number);
	/**
	 * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).
	 */
	set numSolverIterations(value: number);
	/**
	 * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).
	 */
	set numInternalPgsIterations(value: number);
	set minIslandSize(value: number);
	set maxCcdSubsteps(value: number);
}
enum CoefficientCombineRule {
	Average = 0,
	Min = 1,
	Multiply = 2,
	Max = 3
}
class CCDSolver {
	raw: RawCCDSolver;
	/**
	 * Release the WASM memory occupied by this narrow-phase.
	 */
	free(): void;
	constructor(raw?: RawCCDSolver);
}
export interface Shapes {
	circles: number[][];
	lines: number[][];
	paths: number[][];
	rects: number[][];
}
export interface CustomAsset {
	data: {
		shapes: Shapes;
	};
	icon: string;
	id: string;
	name: string;
	optionId: string;
}
export interface WorldCustomAssets {
	customAssets: Map<string, CustomAsset>;
	isUIOpen: boolean;
	updateCounter: number;
}
export interface CodeGridSchema {
	allowChannelGrids: boolean;
	customBlocks: any[];
	triggers: any[];
}
export interface WireConnection {
	id: string;
	name: string;
}
export interface DeviceOption {
	codeGridSchema: CodeGridSchema;
	defaultState: Record<string, any>;
	description?: string;
	id: string;
	initialMemoryCost?: number;
	maxOnMap?: number;
	maximumRoleLevel?: number;
	minimumRoleLevel?: number;
	name?: string;
	optionSchema: {
		options: any[];
	};
	seasonTicketRequired?: boolean;
	subsequentMemoryCost?: number;
	supportedMapStyles?: string[];
	wireConfig: {
		in: {
			connections: WireConnection[];
		};
		out: {
			connections: WireConnection[];
		};
	};
}
export interface DeviceData {
	depth: number;
	deviceOption: DeviceOption;
	existsBeforeReconnect: boolean;
	hooks: any;
	id: string;
	isPreview: boolean;
	layerId: string;
	name: any;
	options: Record<string, any>;
	props: any;
	x: number;
	y: number;
}
export interface CodeGridItem {
	createdAt: number;
	existsBeforeReconnect: boolean;
	json: string;
	triggerType: string;
	owner?: string;
	triggerValue?: string;
	visitors: string[];
}
export interface CodeGrid {
	existsBeforeReconnect: boolean;
	items: Map<string, CodeGridItem>;
}
export interface DeviceState {
	deviceId: string;
	properties: Map<string, any>;
}
export interface WorldDevices {
	codeGrids: Map<string, CodeGrid>;
	devices: Map<string, DeviceData>;
	states: Map<string, DeviceState>;
}
export interface Tile {
	collides: boolean;
	depth: number;
	terrain: string;
	x: number;
	y: number;
}
export interface QueuedTile {
	timestamp: number;
	removedBodyIds: string[];
}
export interface Terrain {
	currentTerrainUpdateId: number;
	modifiedHealth: Map<string, number>;
	queuedTiles: Map<number, QueuedTile>;
	teamColorTiles: Map<string, string>;
	tiles: Map<string, Tile>;
}
export interface GimkitWorld {
	customAssets: WorldCustomAssets;
	devices: WorldDevices;
	height: number;
	width: number;
	mapOptionsJSON: string;
	terrain: Terrain;
	wires: {
		wires: Map<any, any>;
	};
}
export interface ExistingDevice {
	action: string;
	id: string;
	shiftX: number;
	shiftY: number;
	use: boolean;
}
export interface AddingDevices {
	currentlySelectedProp: string;
	existingDevice: ExistingDevice;
	selectedDeviceType: string;
}
export interface AddingTerrain {
	brushSize: number;
	buildTerrainAsWall: boolean;
	currentlySelectedTerrain: string;
	currentlySelectedTerrainDepth: number;
}
export interface AddingWires {
	hoveringOverSupportedDevice: boolean;
	pointUnderMouseDeviceId?: string;
	startDeviceSelected: boolean;
}
export interface Adding {
	devices: AddingDevices;
	terrain: AddingTerrain;
	wires: AddingWires;
	mode: string;
}
export interface CinematicMode {
	charactersVisible: boolean;
	enabled: boolean;
	followingMainCharacter: boolean;
	hidingGUI: boolean;
	mainCharacterVisible: boolean;
	nameTagsVisible: boolean;
}
export interface ClassDesigner {
	activeClassDeviceId: string;
	lastActivatedClassDeviceId: string;
	lastClassDeviceActivationId: number;
}
export interface Context {
	cursorIsOverCharacterId: string;
	__devicesUnderCursor: string[];
	__wiresUnderCursor: Set<string>;
	cursorIsOverDevice: boolean;
	cursorIsOverWire: boolean;
}
export interface MeCustomAssets {
	currentData?: {
		shapes: Shapes;
	};
	currentIcon: string;
	currentId: string;
	currentName: string;
	currentOptionId: string;
	isUIOpen: boolean;
	openOptionId: string | null;
	pendingDeleteId: string | null;
	showDeleteConfirm: boolean;
}
export interface MeDeviceUI {
	current: {
		deviceId: string;
		props: Record<string, any>;
	};
	desiredOpenDeviceId?: string;
	serverVersionOpenDeviceId: string;
}
export interface CurrentlyEditedDevice {
	deviceOptionId: string;
	id: string;
}
export interface SortingState {
	depth: number;
	deviceId: string;
	deviceName: string;
	globalDepth: number;
	layer: string;
	y: number;
}
export interface VisualEditing {
	active: boolean;
	cursor: string;
	id: string;
	instruction: string;
	keyboardHelpers: {
		trigger: string;
		action: string;
	}[];
}
export interface EditingDevice {
	currentlyEditedDevice: CurrentlyEditedDevice;
	currentlyEditedGridId: string;
	currentlySortedDeviceId: string;
	screen: string;
	sortingState: SortingState[];
	usingMultiselect: boolean;
	visualEditing: VisualEditing;
}
export interface EditingPreferences {
	cameraZoom: number;
	movementSpeed: number | null;
	phase: boolean | null;
	showGrid: boolean | null;
	topDownControlsActive: boolean;
}
export interface Editing {
	device: EditingDevice;
	preferences: EditingPreferences;
	wire: {
		currentlyEditedWireId: string;
	};
}
export interface Health {
	fragility: number;
	health: number;
	lives: number;
	maxHealth: number;
	maxShield: number;
	shield: number;
}
export interface InteractiveInfo {
	action: string;
	allowedToInteract: boolean;
	message: string;
	topHeader?: string;
	topHeaderColor: string;
}
export interface Interactives {
	deviceId: string;
	info: InteractiveInfo;
}
export interface InteractiveSlot {
	clipSize: number;
	count: number;
	currentClip: number;
	durability: number;
	itemId: string;
	waiting: boolean;
	waitingEndTime: number;
	waitingStartTime: number;
}
export interface AlertFeed {
	amount: number;
	itemId: string;
}
export interface InventorySlot {
	amount: number;
	existsBeforeReconnect: boolean;
}
export interface Inventory {
	activeInteractiveSlot: number;
	alertFeed?: AlertFeed;
	alertsFeed: AlertFeed[];
	currentWaitingEndTime: number;
	infiniteAmmo: boolean;
	interactiveSlotErrorMessageTimeouts: Map<string, ReturnType<typeof setTimeout>>;
	interactiveSlotErrorMessages: Map<string, string>;
	interactiveSlots: Map<string, InteractiveSlot>;
	interactiveSlotsOrder: number[];
	isCurrentWaitingSoundForItem: boolean;
	lastShotsTimestamps: Map<string, number>;
	maxSlots: number;
	slots: Map<string, InventorySlot>;
}
export interface MobileControls {
	left: boolean;
	right: boolean;
	up: boolean;
}
export interface Mood {
	activeDeviceId: string;
	vignetteActive: boolean;
	vignetteStrength: number;
}
export interface NonDismissMessage {
	description: string;
	title: string;
}
export interface TileToRemove {
	depth: number;
	id: string;
	x: number;
	y: number;
}
export interface Removing {
	deviceIdToRemove?: string;
	removingMode: string;
	removingTilesEraserSize: number;
	removingTilesLayer: number;
	removingTilesMode: string;
	tilesToRemove: TileToRemove[];
	wireIdToRemove?: string;
}
export interface MeSpectating {
	id: string;
	name: string;
	shuffle: boolean;
}
export interface XPAddition {
	amount: number;
	reason: string;
	xp: number;
}
export interface XP {
	additionTimeouts: Map<string, ReturnType<typeof setTimeout>>;
	additions: XPAddition[];
	showingLevelUp: boolean;
}
export interface ZoneDropOverrides {
	allowItemDrop: boolean;
	allowResourceDrop: boolean;
	allowWeaponDrop: boolean;
}
export interface Me {
	adding: Adding;
	cinematicMode: CinematicMode;
	classDesigner: ClassDesigner;
	completedInitialPlacement: boolean;
	context: Context;
	currentAction: string;
	customAssets: MeCustomAssets;
	deviceUI: MeDeviceUI;
	editing: Editing;
	gotKicked: boolean;
	health: Health;
	interactives: Interactives;
	inventory: Inventory;
	isRespawning: boolean;
	mobileControls: MobileControls;
	mood: Mood;
	movementSpeed: number;
	myTeam: string;
	nonDismissMessage: NonDismissMessage;
	phase: boolean;
	preferences: {
		startGameWithMode: string;
	};
	properties: Map<string, any>;
	removing: Removing;
	roleLevel: number;
	spawnPosition: Vector;
	spectating: MeSpectating;
	teleportCount: number;
	unredeemeedXP: number;
	xp: XP;
	zoneDropOverrides: ZoneDropOverrides;
}
export interface CallToActionCategory {
	id: string;
	name: string;
	plural: string;
}
export interface CallToActionItem {
	id: string;
	category: string;
	name: string;
	url: string;
}
export interface Widget {
	type: string;
	id: string;
	y: number;
	placement: string;
	statName: string;
	statValue: number;
}
export interface GameSession {
	callToAction: {
		categories: CallToActionCategory[];
		items: CallToActionItem[];
	};
	countdownEnd: number;
	phase: string;
	resultsEnd: number;
	widgets: {
		widgets: Widget[];
	};
}
export interface Session {
	allowGoogleTranslate: boolean;
	amIGameOwner: boolean;
	canAddGameTime: boolean;
	cosmosBlocked: boolean;
	customTeams: {
		characterToTeamMap: Map<string, string>;
	};
	duringTransition: boolean;
	gameClockDuration: string;
	gameOwnerId: string;
	gameSession: GameSession;
	gameTime: number;
	gameTimeLastUpdateAt: number;
	globalPermissions: Permissions;
	loadingPhase: boolean;
	mapCreatorRoleLevel: number;
	mapStyle: string;
	modeType: string;
	ownerRole: string;
	phase: string;
	phaseChangedAt: number;
	version: string;
}
export interface Achievement {
	id: string;
	key: string;
	reset: () => void;
	update: () => void;
}
export interface BottomInGamePrimaryContent {
	interactionWantsToBeVisible: boolean;
	prioritizeInteraction: boolean;
}
export interface DamageIndicator {
	show: boolean;
	/** `h` for red, `s` for blue, and any other string for yellow. */
	type: string;
}
export interface GuiSlot {
	id: string;
	position: string;
	text: string;
	trackedItemId: string | null;
	showTrackedItemMaximumAmount: boolean;
	type: string;
	priority: number;
	color: string;
}
export interface KnockoutAlert {
	id: string;
	name: string;
}
export interface Modals {
	closeAllModals: () => void;
	cosmosModalOpen: boolean;
	switchToRegisterScreenWhenCosmosModalOpens: boolean;
}
export interface NoneGui {
	addMenu: {
		screen: string;
	};
	duringGameScreenVisible: boolean;
	optionsMenu: {
		screen: string;
	};
	screen: string;
}
export interface Scorebar {
	teamColors: string[];
	teams: string[];
}
export interface GUI {
	achievement: Achievement;
	bottomInGamePrimaryContent: BottomInGamePrimaryContent;
	damageIndicator: DamageIndicator;
	guiSlots: GuiSlot[];
	guiSlotsChangeCounter: number;
	knockoutAlerts: KnockoutAlert[];
	modals: Modals;
	none: NoneGui;
	openInputBlockingUI: string[];
	playersManagerUpdateCounter: number;
	scale: number;
	scorebar?: Scorebar;
	selectedPlayerId: string;
	showingGrid: boolean;
}
export interface CharacterPermissions {
	adding: boolean;
	editing: boolean;
	manageCodeGrids: boolean;
	removing: boolean;
}
export interface CharacterInfo {
	allowWeaponFire: boolean;
	existsBeforeReconnect: boolean;
	fragility: number;
	health: number;
	id: string;
	isActive: boolean;
	lastPlayersTeamId: string;
	name: string;
	permissions: CharacterPermissions;
	score: number;
	teamId: string;
	type: string;
}
export interface Characters {
	characters: Map<string, CharacterInfo>;
}
export interface Costs {
	codeGrid: number;
	collidingTile: number;
	customAssetDefault: number;
	deviceInitialDefault: number;
	deviceSubsequentDefault: number;
	nonCollidingTile: number;
	wire: number;
}
export interface Counters {
	codeGrids: number;
	collidingTiles: number;
	customAssets: Map<string, number>;
	devices: Map<string, number>;
	nonCollidingTiles: number;
	wires: number;
}
export interface Limits {
	blocksPerCodeGrid: number;
	codeGrids: number;
	codeGridsPerDevice: number;
	collidingTiles: number;
	customAssetOnMapDefault: number;
	deviceMaxOnMapDefault: number;
	nonCollidingTiles: number;
	wires: number;
}
export interface MemorySystem {
	costs: Costs;
	counters: Counters;
	limits: Limits;
	maxUsedMemory: number;
	usedMemoryCost: number;
}
export interface Rect {
	x: number;
	y: number;
	width: number;
	height: number;
}
export interface RotatedRect extends Rect {
	angle: number;
}
export interface Circle {
	x: number;
	y: number;
	radius: number;
}
export interface RotatedCircle extends Circle {
	angle: number;
}
export interface Ellipse {
	x: number;
	y: number;
	r1: number;
	r2: number;
}
export interface RotatedEllipse extends Ellipse {
	angle: number;
}
export interface RectShort {
	x: number;
	y: number;
	w: number;
	h: number;
}
export interface RotatedRectShort extends RectShort {
	angle: number;
}
export interface CircleShort {
	x: number;
	y: number;
	r: number;
}
export interface CodeGrids {
	blockCategories: string;
	customBlocks: string;
	customBlocksParsed: any[];
}
export interface OptionSchema {
	options: any[];
	categories?: any[];
}
export interface DeviceInfo {
	id: string;
	name: string;
	description?: string;
	optionSchema: OptionSchema;
	defaultState: any;
	codeGridSchema: CodeGridSchema;
	wireConfig?: any;
	minimumRoleLevel?: number;
	maxOnMap?: number;
	initialMemoryCost?: number;
	subsequentMemoryCost?: number;
	supportedMapStyles?: string[];
	seasonTicketRequired?: boolean;
	maximumRoleLevel?: number;
}
export interface ItemOption {
	type: string;
	id: string;
	name: string;
	editorName: string;
	description: string;
	previewImage: string;
	rarity?: string;
	weapon?: Weapon;
	minimumRoleLevel?: number;
	useCommand?: string;
	consumeType?: string;
	terrainId?: string;
	maxStackSize?: number;
}
export interface Weapon {
	type: string;
	appearance: string;
	shared: WeaponShared;
	bullet?: {
		ammoItemId: string;
	};
}
export interface WeaponShared {
	cooldownBetweenShots: number;
	allowAutoFire: boolean;
	startingProjectileDistanceFromCharacter: number;
}
export interface PropOption {
	id: string;
	name: string;
	scaleMultip: number;
	originX: number;
	originY: number;
	imageUrl: string;
	rectColliders: RotatedRectShort[];
	circleColliders: CircleShort[];
	ellipseColliders: RotatedEllipse[];
	shadows: Ellipse[];
	seasonTicketRequired?: boolean;
	minimumRoleLevel?: number;
	defaultLayer?: string;
}
export interface SkinOption {
	id: string;
	name: string;
	minimumRoleLevel?: number;
}
export interface TerrainOption {
	id: string;
	name: string;
	maskTilesUrl: string;
	borderTilesUrl: string;
	fillUrl: string;
	blockedMapStyles?: string[];
	seasonTicketRequired?: boolean;
	previewUrl: string;
	health?: number;
	minimumRoleLevel?: number;
}
export interface CustomAssetOption {
	id: string;
	maxOnMap: number;
	memoryCost: number;
	minimumRoleLevel?: number;
	validate: any;
}
export interface WorldOptions {
	codeGrids: CodeGrids;
	customAssetsOptions: CustomAssetOption[];
	deviceOptions: DeviceInfo[];
	hasAllProps: boolean;
	itemOptions: ItemOption[];
	propsOptions: PropOption[];
	skinOptions: SkinOption[];
	terrainOptions: TerrainOption[];
}
export interface AppearanceVariation {
	device: Device;
	resetAppearance(): void;
	setPreviewAppearance(): void;
	setRemovalAppearance(): void;
}
export interface BoundingBox {
	cachedBoundingBox: Rect;
	device: Device;
	hardcodedBoundingBox?: Rect;
	clearCached(): void;
	clearHardcoded(): void;
	getBoundingBox(): Rect;
	isHardcoded(): boolean;
	isInsideBoundingBox(x: number, y: number): boolean;
	setHardcoded(rect: Rect): void;
}
export type DeviceCollider = RectShort | CircleShort | Ellipse;
export type ColliderOptions = {
	device: Device;
	scene: Scene;
	angle: number;
	x: number;
	y: number;
} & Partial<RectShort & CircleShort & Ellipse>;
export interface ColliderEntry {
	bodyId: string;
	options: ColliderOptions;
	device: Device;
	scene: Scene;
}
export interface Colliders {
	add: {
		box(collider: RectShort): void;
		circle(collider: CircleShort): void;
		ellipse(collider: Ellipse): void;
	};
	device: Device;
	list: ColliderEntry[];
	createOptions(collider: DeviceCollider): ColliderOptions;
	destroy(): void;
	forEach(callback: (collider: DeviceCollider) => void): void;
	hideDebug(): void;
	showDebug(): void;
}
export interface UpdateCullOptions {
	mainCharacter: Character;
	isPhase: boolean;
	insideView: boolean;
}
export interface Cull {
	device: Device;
	ignoresCull: boolean;
	isInsideView: boolean;
	margin: number;
	wasInsideView: boolean;
	getMargin(): number;
	ignoreCulling(): void;
	setMargin(margin: number): void;
	setOnEnterViewCallback(callback: () => void): void;
	setOnLeaveViewCallback(callback: () => void): void;
	onEnterViewCallback?(): void;
	onLeaveViewCallback?(): void;
	updateCull(options: UpdateCullOptions): void;
}
export interface DeviceUI {
	device: Device;
	close(): void;
	open(options: Record<string, any>): void;
	update(options: Record<string, any>): void;
}
export interface DeviceInput {
	device: Device;
	enabled: boolean;
	hasKeyListeners: boolean;
	isCurrentlyUnderMouse: boolean;
	addDeviceToCursorUnderList(): void;
	createKeyListeners(): void;
	cutCopyHandler(action: string): void;
	disable(): void;
	dispose(): void;
	disposeKeyListeners(): void;
	enable(): void;
	partIsNoLongerUnderMouse(): void;
	partIsUnderMouse(): void;
	removeDeviceFromCursorUnderList(): void;
}
export interface InteractiveZones {
	add: {
		circle(zone: CircleShort): void;
		rect(zone: Rect): void;
	};
	canInteractThroughColliders: boolean;
	device: Device;
	forceDisabled: boolean;
	zones: (CircleShort | Rect)[];
	contains(x: number, y: number): boolean;
	destroy(): void;
	getCanInteractThroughColliders(): boolean;
	getInfo(): any;
	getMaxDistance(x: number, y: number): number;
	isInteractive(): boolean;
	onPlayerCanInteract(): void;
	onPlayerCantInteractAnyMore(): void;
	setCanInteractThroughColliders(canInteract: boolean): void;
	setForceDisabled(forceDisabled: boolean): void;
	setInfo(info: any): void;
	remove(zone: CircleShort | Rect): void;
	onInteraction?(): void;
}
export interface VisualEditingBox {
	width: number;
	height: number;
	angle: number;
	minWidth: number;
	maxWidth: number;
	minHeight: number;
	maxHeight: number;
	keepRatio: boolean;
	rotable: boolean;
	onChange(value: RotatedRect): void;
}
export interface VisualEditingCircle {
	angle: number;
	rotable: boolean;
	radius: number;
	minRadius: number;
	maxRadius: number;
	onChange(value: RotatedCircle): void;
}
export interface DeviceVisualEditing {
	add: {
		box(options: VisualEditingBox): void;
		circle(options: VisualEditingCircle): void;
	};
	device: Device;
	isActive: boolean;
	shapes: (VisualEditingBox | VisualEditingCircle)[];
	clear(): void;
}
export interface ShadowOptions {
	x: number;
	y: number;
	r1: number;
	r2: number;
	alphaMultip: number;
	depth: number;
}
export interface Shadows {
	device: Device;
	list: ShadowOptions[];
	add(options: ShadowOptions): void;
	destroy(): void;
	forEach(callback: (shadow: ShadowOptions) => void): void;
	hide(): void;
	show(): void;
}
export interface Layers {
	depth: number;
	device: Device;
	layer: string;
	options: any;
}
export interface WirePoints {
	device: Device;
	end: Vector;
	start: Vector;
	onPointChange(): void;
	setBoth(x: number, y: number): void;
}
export interface DeviceTweens {
	list: Tweens.Tween[];
	device: Device;
	add(config: Types.Tweens.TweenBuilderConfig): Tweens.Tween;
	destroy(): void;
}
export interface DeviceProjectiles {
	device: Device;
	addToDynamicDevices(): void;
	collidesWithProjectile(object: Circle): boolean;
	onClientPredictedHit(position: Vector): void;
	removeFromDynamicDevices(): void;
	setDynamic(dynamic: boolean): void;
}
export interface BaseDevice {
	isPreview: boolean;
	placedByClient: boolean;
	isDestroyed: boolean;
	x: number;
	y: number;
	forceUseMyState: boolean;
	options: Record<string, any>;
	state: Record<string, any>;
	prevState: Record<string, any>;
	name: string;
	id: string;
	scene: Scene;
	deviceOption: DeviceOption;
	visualEditing: DeviceVisualEditing;
	shadows: Shadows;
	input: DeviceInput;
	parts: any;
	cull: Cull;
	boundingBox: BoundingBox;
	appearanceVariation: AppearanceVariation;
	colliders: Colliders;
	interactiveZones: InteractiveZones;
	deviceUI: DeviceUI;
	layers: Layers;
	wirePoints: WirePoints;
	tweens: DeviceTweens;
	projectiles: DeviceProjectiles;
	sensors: any;
	onHide: (() => void) | null;
	onShow: (() => void) | null;
	onUpdate: (() => void) | null;
	initialStateProcessing(state: Record<string, any>): Record<string, any>;
	getMaxDepth(): number;
	onStateUpdateFromServer(key: string, value: any): void;
	getRealKey(key: string): string;
	onPostUpdate(): void;
	onInit(): void;
	onMessage(message: {
		key: string;
		data: any;
	}): void;
	onStateChange(key: string): void;
	onDestroy(options: {
		isBeingReplaced: boolean;
	}): void;
	sendToServerDevice(key: string, data: any): void;
	openDeviceUI(): void;
	checkIfCollidersEnabled(): boolean;
	destroy(options: {
		isBeingReplaced: boolean;
	}): void;
}
export type Device = BaseDevice & {
	[key: string]: any;
};
export interface Jump {
	/** Optional in top-down, required in platformer */
	actuallyJumped?: boolean;
	isJumping: boolean;
	jumpCounter: number;
	jumpTicks: number;
	jumpsLeft: number;
	xVelocityAtJumpStart: number;
}
export interface MovementState {
	accelerationTicks: number;
	direction: string;
	xVelocity: number;
}
export interface PhysicsState {
	forces: any[];
	gravity: number;
	grounded: boolean;
	groundedTicks: number;
	jump: Jump;
	lastGroundedAngle: number;
	movement: MovementState;
	velocity: Vector;
}
export interface PhysicsInput extends TickInput {
	activeClassDeviceId: string;
	ignoredStaticBodies: Set<any>;
	ignoredTileBodies: Set<any>;
	projectileHitForcesQueue: Set<any>;
}
export interface CharacterBody {
	id: string;
	ignoredStaticBodies: Set<any>;
	ignoredTileBodies: Set<any>;
	controller: KinematicCharacterController;
	aroundSensor: Collider;
	feetSensor: Collider;
}
export interface Bodies {
	character: CharacterBody;
	collider: Collider;
	colliderDesc: ColliderDesc;
	rigidBody: RigidBody;
	rigidBodyDesc: RigidBodyDesc;
}
export interface ServerPosition {
	packet: number;
	x: number;
	y: number;
	jsonState: string;
	teleport: boolean;
}
export type AngleInput = number | null;
export interface TickInput {
	angle: AngleInput;
	jump: boolean;
	_jumpKeyPressed: boolean;
}
export interface Physics {
	character: Character;
	currentPacketId: number;
	frameInputsHistory: Map<number, PhysicsInput>;
	justAppliedProjectileHitForces: Set<any>;
	lastClassDeviceActivationId: number;
	lastPacketSent: number[];
	lastSentClassDeviceActivationId: number;
	lastSentTerrainUpdateId: number;
	lastTerrainUpdateId: number;
	newlyAddedTileBodies: Set<any>;
	phase: boolean;
	physicsBodyId: string;
	prevState: PhysicsState;
	projectileHitForcesHistory: Map<any, any>;
	projectileHitForcesQueue: Set<any>;
	scene: Scene;
	state: PhysicsState;
	tickInput: TickInput;
	destroy(): void;
	getBody(): Bodies;
	postUpdate(dt: number): void;
	preUpdate(): void;
	sendToServer(): void;
	setServerPosition(serverPosition: ServerPosition): void;
	setupBody(x: number, y: number): void;
	updateDebugGraphics(): void;
}
export interface AimCursor {
	aimCursor: GameObjects.Sprite;
	aimCursorWorldPos: Vector;
	centerShiftX: number;
	centerShiftY: number;
	scene: Scene;
	x: number;
	y: number;
	update(): void;
}
export interface Cursor {
	scene: Scene;
	createStateListeners(): void;
	updateCursor(): void;
}
export interface PressedKeys {
	up: boolean;
	down: boolean;
	left: boolean;
	right: boolean;
}
export interface KeyboardState {
	isHoldingDown: boolean;
	isHoldingLeft: boolean;
	isHoldingRight: boolean;
	isHoldingUp: boolean;
	isHoldingSpace: boolean;
}
export interface Keyboard {
	heldKeys: Set<number>;
	scene: Scene;
	state: KeyboardState;
	createListeners(): void;
	isKeyDown(key: number): boolean;
}
export interface MovementPointer {
	id: string;
	x: number;
	y: number;
	downX: number;
	downY: number;
}
export interface Mouse {
	clickListeners: Map<string, (pointer: Input.Pointer) => void>;
	downX: number;
	downY: number;
	isHoldingDown: boolean;
	movementPointer?: MovementPointer;
	scene: Scene;
	stopRunningClickHandlers: boolean;
	worldX: number;
	worldY: number;
	x: number;
	y: number;
	addClickListener(options: {
		callback: (pointer: Input.Pointer) => void;
	}): () => void;
	pointerUpdate(pointer: Input.Pointer): void;
	removeClickListener(id: string): void;
	shouldBecomeMovementPointer(pointer: Input.Pointer): boolean;
}
export interface InputManager {
	aimCursor: AimCursor;
	angleSinceLastPhysicsFetch: AngleInput;
	currentInput: TickInput;
	cursor: Cursor;
	isListeningForInput: boolean;
	jumpedSinceLastPhysicsFetch: boolean;
	keyboard: Keyboard;
	mouse: Mouse;
	physicsInputHandledBetweenUpdates: boolean;
	scene: Scene;
	getAimingDirection(): Vector;
	getInputAngle(): number | null;
	getKeys(): PressedKeys;
	getMouseWorldXY(): Vector;
	getPhysicsInput(): TickInput;
	refreshInput(): void;
	update(): void;
}
export interface Cameras {
	allCameras: Device[];
	allCamerasNeedsUpdate: boolean;
	camerasPlayerIsInside: any[];
	scene: Scene;
	wasInPrePhase: boolean;
	findNewCameras(allCameras: Device[], x: number, y: number): any;
	setCurrentCameraSizeDevice(device: Device): void;
	switchToDefaultCameraSize(reset: boolean): void;
	update(devices: Device[]): void;
}
export interface DevicesAction {
	inputManager: InputManager;
	scene: Scene;
	onClick(arg: any): void;
	update(): void;
}
export interface DevicesPreview {
	devicePreviewOverlay: Overlay;
	previousDevices: Device[];
	scene: Scene;
	removePreviousDevices(isBeingReplaced: boolean): void;
	update(): void;
}
export interface WorldInteractives {
	scene: Scene;
	currentDevice?: Device;
	clearCurrentDevice(): void;
	setCurrentDevice(device: Device): void;
	update(devices: Device[]): void;
	canBeReachedByPlayer(device: Device): boolean;
	findClosestInteractiveDevice(devices: Device[], x: number, y: number): Device | undefined;
}
export interface Devices {
	allDevices: Device[];
	cameras: Cameras;
	devicesAction: DevicesAction;
	devicesInView: Device[];
	devicesPreview: DevicesPreview;
	devicesToPostUpdate: Set<Device>;
	devicesToUpdate: Set<Device>;
	interactives: WorldInteractives;
	scene: Scene;
	visualEditingManager: any;
	addDevice(device: Device): void;
	cullDevices(): void;
	findDeviceUnderMouse(): Device | undefined;
	getDeviceById(id: string): Device | undefined;
	hasDevice(id: string): boolean;
	removeDeviceById(id: string, options: {
		isBeingReplaced: boolean;
	}): void;
	update(dt: number): void;
}
export interface CreateTileOptions {
	x: number;
	y: number;
	tileIndex: number;
	terrainOption: TerrainOption;
}
export interface InGameTerrainBuilder {
	afterFailureWithTouch: boolean;
	overlay: Overlay;
	previewingTile?: Vector;
	scene: Scene;
	wasDown: boolean;
	clearConsumeErrorMessage(): void;
	clearPreviewLayer(): void;
	createPreviewTile(options: CreateTileOptions): void;
	update(): void;
}
export interface ActiveBodies {
	activeBodies: Set<string>;
	bodyManager: BodyManager;
	currentCoordinateKeys: Set<string>;
	world: World;
	disableBody(id: string): void;
	enable(keys: Set<string>, setAll: boolean): void;
	enableBodiesAlongLine(options: {
		start: Vector;
		end: Vector;
	}): void;
	enableBodiesWithinAreas(options: {
		areas: Rect[];
		disableActiveBodiesOutsideArea: boolean;
	}): void;
	enableBody(id: string): void;
	setDirty(): void;
}
export interface BodyBounds {
	minX: number;
	minY: number;
	maxX: number;
	maxY: number;
}
export interface BodyStatic {
	bounds: BodyBounds;
	cells: Set<string>;
}
export interface GimkitBody {
	collider?: Collider;
	colliderDesc: ColliderDesc;
	rigidBody?: RigidBody;
	rigidBodyDesc: RigidBodyDesc;
	static: BodyStatic;
	device?: {
		id: string;
	};
	terrain?: {
		key: string;
	};
}
export interface BodyManager {
	activeBodies: ActiveBodies;
	bodies: Map<string, GimkitBody>;
	cells: Map<string, Set<string>>;
	dynamicBodies: Set<string>;
	gridSize: number;
	staticBodies: Set<string>;
	staticSensorBodies: Set<string>;
	_idCount: number;
	find(id: string): GimkitBody | undefined;
	findPotentialStaticBodiesWithinArea(area: Rect): Set<string>;
	generateId(): void;
	insert(body: GimkitBody): string;
	remove(id: string): void;
}
export interface WorldBoundsCollider {
	body: RigidBody;
	collider: Collider;
}
export interface PhysicsManager {
	bodies: BodyManager;
	cumulTime: number;
	lastTime: number;
	physicsStep(dt: number): void;
	runPhysicsLoop(dt: number): void;
	world: World;
	worldBoundsColliders: Set<WorldBoundsCollider>;
}
export interface Projectile {
	id: string;
	startTime: number;
	endTime: number;
	start: Vector;
	end: Vector;
	radius: number;
	appearance: string;
	ownerId: string;
	ownerTeamId: string;
	damage: number;
	hitPos?: Vector;
	hitTime?: number;
}
export interface Projectiles {
	damageMarkers: any;
	dynamicDevices: Set<Device>;
	fireSlashes: any;
	projectileJSON: Map<string, Projectile>;
	runClientSidePrediction: boolean;
	scene: Scene;
	addProjectile(projectile: Projectile): void;
	fire(pointer: Input.Pointer, snap: boolean): void;
	update(): void;
}
export interface WorldManager {
	devices: Devices;
	inGameTerrainBuilder: InGameTerrainBuilder;
	physics: PhysicsManager;
	projectiles: Projectiles;
	scene: Scene;
	terrain: any;
	wires: any;
	update(dt: number): void;
}
export interface BackgroundLayersManager {
	layerManager: LayerManager;
	scene: Scene;
	createLayer(options: {
		layerId: string;
		depth: number;
	}): void;
	fill(terrain: TerrainOption): void;
	fillForPlatformer(): void;
	fillForTopDown(terrain: TerrainOption): void;
	removeLayer(options: {
		layerId: string;
	}): void;
}
export interface LayerManager {
	backgroundLayersManager: BackgroundLayersManager;
	colliders: Map<string, Map<string, string>>;
	layers: Map<string, any>;
	scene: Scene;
	createInitialLayers(): void;
	createLayer(id: string): void;
	fillBottomLayer(terrain: TerrainOption): void;
	getActualLayerDepth(id: string): number;
	moveLayersAboveCharacters(): void;
	onWorldSizeChange(): void;
}
export interface TileKey {
	depth: number;
	x: number;
	y: number;
}
export interface TileManager {
	cumulTime: number;
	scene: Scene;
	layerManager: LayerManager;
	damageTileAtXY(x: number, y: number, depth: number, damage: number, healthPercent: number): void;
	destroyTileByTileKey(tileKey: TileKey): void;
	onMapStyleSet(): void;
	regenerateTileAtXY(x: number, y: number, depth: number, healthPercent: number): void;
	update(dt: number): void;
	updateTeamColorTileAtXY(x: number, y: number, depth: number, team?: string, playerId?: string): void;
}
export interface ShowOverlayOptions {
	x: number;
	y: number;
	width: number;
	height: number;
	depth: number;
}
export interface Overlay {
	scene: Scene;
	showing: boolean;
	showingDimensions: {
		width: number;
		height: number;
	} | null;
	showingPosition: {
		x: number;
		y: number;
	} | null;
	hide(): void;
	show(options: ShowOverlayOptions): void;
}
export interface DepthSort {
	overlay: Overlay;
	scene: Scene;
	update(): void;
}
export interface SelectedDevicesOverlay {
	graphics: GameObjects.Graphics;
	scene: Scene;
	showing: boolean;
	hide(): void;
	show(rects: Rect[]): void;
}
export interface MultiSelect {
	boundingBoxAroundEverything: Rect | null;
	currentlySelectedDevices: Device[];
	currentlySelectedDevicesIds: string[];
	hidingSelectionForDevices: boolean;
	isSelecting: boolean;
	modifierKeyDown: boolean;
	mouseShifts: Vector[];
	movedOrCopiedDevices: Device[];
	overlay: Overlay;
	scene: Scene;
	selectedDevices: Device[];
	selectedDevicesIds: string[];
	selectedDevicesOverlay: SelectedDevicesOverlay;
	selection: Rect | null;
	addDeviceToSelection(device: Device): void;
	endSelectionRect(): void;
	findSelectedDevices(): void;
	hasSomeSelection(): boolean;
	hideSelection(): void;
	multiselectDeleteKeyHandler(): void;
	multiselectKeyHandler(down: boolean): void;
	onDeviceAdded(device: Device): void;
	onDeviceRemoved(id: string): void;
	setShiftParams(): void;
	startSelectionRect(): void;
	unselectAll(): void;
	update(): void;
	updateSelectedDevicesOverlay(): void;
	updateSelectionRect(): void;
}
export interface PlatformerEditing {
	setTopDownControlsActive(active: boolean): void;
}
export interface Removal {
	overlay: Overlay;
	prevMouseWasDown: boolean;
	scene: Scene;
	checkForItem(): void;
	createStateListeners(): void;
	removeSelectedItems(): void;
	update(): void;
}
export interface ActionManager {
	depthSort: DepthSort;
	multiSelect: MultiSelect;
	platformerEditing: PlatformerEditing;
	removal: Removal;
	update(): void;
}
export interface Spectating {
	findNewCharacter(): void;
	onBeginSpectating(): void;
	onEndSpectating(): void;
	setShuffle(shuffle: boolean, save?: boolean): void;
}
export interface CharacterOptions {
	id: string;
	x: number;
	y: number;
	scale: number;
	type: string;
}
export interface CharacterManager {
	characterContainer: GameObjects.Container;
	characters: Map<string, Character>;
	scene: Scene;
	spectating: Spectating;
	addCharacter(options: CharacterOptions): Character;
	cullCharacters(): void;
	removeCharacter(id: string): void;
	update(dt: number): void;
}
export interface Scene extends BaseScene {
	actionManager: ActionManager;
	cameraHelper: any;
	characterManager: CharacterManager;
	dt: number;
	inputManager: InputManager;
	resizeManager: any;
	shadowsManager: any;
	spine: any;
	tileManager: TileManager;
	uiManager: any;
	worldManager: WorldManager;
	create(): void;
}
export interface SoundEffect {
	path: string;
	volume: number;
}
export interface BaseAsset {
	frameHeight: number;
	frameRate: number;
	frameWidth: number;
	imageUrl: string;
	scale: number;
}
export interface ImpactAsset extends BaseAsset {
	frames: number[];
	hideIfNoHit?: boolean;
}
export interface WeaponAsset extends BaseAsset {
	fireFrames: number[];
	fromCharacterCenterRadius: number;
	hideFireSlash: boolean;
	idleFrames: number;
	originX: number;
	originY: number;
}
export interface ProjectileAppearance {
	imageUrl: string;
	rotateToTarget: boolean;
	scale: number;
}
export interface CurrentAppearance {
	id: string;
	explosionSfx: SoundEffect[];
	fireSfx: SoundEffect[];
	impact: ImpactAsset;
	projectile: ProjectileAppearance;
	reloadSfx: SoundEffect;
	weapon: WeaponAsset;
}
export interface AimingAndLookingAround {
	angleTween?: Tweens.Tween;
	character: Character;
	currentAngle?: number;
	currentAppearance?: CurrentAppearance;
	currentWeaponId?: string;
	isAiming: boolean;
	lastUsedAngle: number;
	sprite: GameObjects.Sprite;
	targetAngle?: number;
	characterShouldFlipX(): boolean;
	destroy(): void;
	isCurrentlyAiming(): boolean;
	onInventoryStateChange(): void;
	playFireAnimation(): void;
	setImage(appearance: CurrentAppearance): void;
	setSpriteParams(skipRecalculateAlpha: boolean): void;
	setTargetAngle(angle: number, instant?: boolean): void;
	update(): void;
	updateAnotherCharacter(): void;
	updateMainCharacterMouse(): void;
	updateMainCharacterTouch(): void;
}
export interface NonMainCharacterState {
	grounded: boolean;
}
export interface CharacterAnimation {
	availableAnimations: string[];
	blinkTimer: number;
	bodyAnimationLocked: boolean;
	bodyAnimationStartedAt: number;
	character: Character;
	currentBodyAnimation: string;
	currentEyeAnimation: string;
	lastGroundedAnimationAt: number;
	nonMainCharacterState: NonMainCharacterState;
	prevNonMainCharacterState: NonMainCharacterState;
	skinChanged: boolean;
	destroy(): void;
	onAnimationComplete(options: any): void;
	onSkinChanged(): void;
	playAnimationOrClearTrack(animations: string[], track: number): void;
	playBodyAnimation(animation: string): void;
	playBodySupplementalAnimation(animation: string): void;
	playEyeAnimation(animation: string): void;
	playJumpSupplementalAnimation(animation: string): void;
	playMovementSupplementalAnimation(animation: string): void;
	setupAnimations(): void;
	startBlinkAnimation(): void;
	stopBlinkAnimation(): void;
	update(dt: number): void;
}
export interface Point {
	endTime: number;
	endX: number;
	endY: number;
	startTime: number;
	startX: number;
	startY: number;
	teleported: boolean;
	usedTeleported: boolean;
}
export interface EndInfo {
	end: number;
	start: number;
	x: number;
	y: number;
}
export interface Movement {
	character: Character;
	currentPoint: Point;
	currentTime: number;
	nonMainCharacterGrounded: boolean;
	pointMap: Point[];
	targetIsDirty: boolean;
	targetNonMainCharacterGrounded: boolean;
	targetX: number;
	targetY: number;
	teleportCount: number;
	teleported: boolean;
	getCurrentEndInfo(): EndInfo;
	moveToTargetPosition(): void;
	onMainCharacterTeleport(): void;
	postPhysicsUpdate(dt: number): void;
	setNonMainCharacterTargetGrounded(grounded: boolean): void;
	setTargetX(x: number): void;
	setTargetY(y: number): void;
	setTeleportCount(teleportCount: number): void;
	update(dt: number): void;
}
export interface Updates {
	update(update: {
		delta: number;
	}): void;
	updateAlpha(): void;
	updateDepth(): void;
	updatePosition(dt: number): void;
	updateScale(): void;
}
export interface TeamState {
	status: string;
	teamId: string;
}
export interface TweenAlphaOptions {
	alpha: number;
	type: string;
	duration: number;
	ease?: string;
}
export interface Alpha {
	character: Character;
	cinematicModeAlpha: number;
	currentAlpha: number;
	immunity: number;
	phaseAlpha: number;
	playerAppearanceModifierDeviceAlpha: number;
	scene: Scene;
	getCurrentAlpha(): number;
	setAlpha(type: string, alpha: number): void;
	tweenAlpha(options: TweenAlphaOptions): void;
	update(): void;
}
export interface TrailEmitter {
	frequency: number;
	quantity: number;
	blendMode: number;
	speed: number;
	speedVariation: number;
	lifetime: number;
	lifetimeVariation: number;
	scale: number;
	scaleVariation: number;
	scaleThreshold: number;
	rotationRandomAtStart: boolean;
	rotationChange: number;
	rotationChangeVariation: number;
	rotationAllowNegativeChange: boolean;
	alphaThresholdStart: number;
	alphaThresholdEnd: number;
	gravityY: number;
	yOriginChange: number;
	emitterZone: Partial<Vector>;
}
export interface TrailParticles {
	frameHeight: number;
	frameWidth: number;
	imageUrl: string;
	numberOfFrames: number;
}
export interface TrailAppearance {
	id: string;
	emitter: TrailEmitter;
	particles: TrailParticles;
}
export interface CharacterTrail {
	character: Character;
	currentAppearance: TrailAppearance;
	currentAppearanceId: string;
	isReady: boolean;
	lastSetAlpha: number;
	destroy(): void;
	followCharacter(): void;
	setNewAppearance(appearance: TrailAppearance): void;
	update(): void;
	updateAppearance(id: string): void;
}
export interface Culling {
	character: Character;
	isInCamera: boolean;
	needsCullUpdate: boolean;
	scene: Scene;
	shouldForceUpdate: boolean;
	forceUpdate(): void;
	hideObject(object: any): void;
	onInCamera(): void;
	onOutCamera(): void;
	showObject(object: any): void;
	updateNeedsUpdate(): void;
}
export interface Depth {
	character: Character;
	currentDepth: number;
	lastY: number;
	update(): void;
	updateDepth(): void;
}
export interface Dimensions {
	character: Character;
	currentDimensionsId: string;
	bottomY: number;
	centerX: number;
	topY: number;
	x: number;
	onPotentialDimensionsChange(): void;
}
export interface Flip {
	character: Character;
	flipXLastX: number;
	isFlipped: boolean;
	lastX: number;
	lastY: number;
	update(): void;
	updateFlipForMainCharacter(): void;
	updateFlipForOthers(): void;
}
export interface Healthbar extends Updates {
	character: Character;
	depth: number;
	isVisible: boolean;
	scene: Scene;
	destroy(): void;
	makeIndicator(): void;
	updateValue(): void;
}
export interface Immunity {
	character: Character;
	classImmunityActive: boolean;
	spawnImmunityActive: boolean;
	activate(): void;
	activateClassImmunity(): void;
	activateSpawnImmunity(): void;
	deactivate(): void;
	deactivateClassImmunity(): void;
	deactivateSpawnImmunity(): void;
	isActive(): boolean;
}
export interface ImpactAnimation {
	animations: Map<string, GameObjects.Sprite>;
	character: Character;
	loadedAnimations: Set<string>;
	scene: Scene;
	_play(animation: string): void;
	destroy(): void;
	load(animation: string): void;
	play(animation: string): void;
}
export interface Indicator extends Updates {
	character: Character;
	characterHeight: number;
	depth: number;
	image: GameObjects.Image;
	isMain: boolean;
	isSpectated: boolean;
	lastCharacterAlpha: number;
	scene: Scene;
	teamState: TeamState;
	destroy(): void;
	makeIndicator(): void;
}
export interface CharacterInput {
	character: Character;
	isListeningForInput: boolean;
	scene: Scene;
	setupInput(): void;
}
export interface Nametag {
	alpha: number;
	character: Character;
	creatingTag: boolean;
	depth: number;
	destroyed: boolean;
	followScale: boolean;
	fragilityTag?: GameObjects.Text;
	healthMode: string;
	name: string;
	scale: number;
	scene: Scene;
	tag: GameObjects.Text;
	teamState: TeamState;
	fontColor: string;
	tags: GameObjects.Text[];
	createFragilityTag(): void;
	createTag(): void;
	destroy(): void;
	makeVisibleChanges(force?: boolean): void;
	playHideAnimation(): void;
	playShowUpAnimation(): void;
	setName(name: string): void;
	update(update: {
		teamState: TeamState;
	}): void;
	updateFontColor(): void;
	updateFragility(fragility: number): void;
	updateTagAlpha(force?: boolean): void;
	updateTagDepth(force?: boolean): void;
	updateTagPosition(force?: boolean): void;
	updateTagScale(force?: boolean): void;
}
export interface Network {
	lastAngle?: number;
	lastAngleUpdate: number;
	updateAimAngle(angle: number): void;
}
export interface CharacterPosition {
	character: Character;
	update(dt: number): void;
}
export interface TweenScaleOptions {
	type: string;
	scale: number;
	duration: number;
}
export interface Scale {
	activeScale: number;
	baseScale: number;
	character: Character;
	respawningScale: number;
	scaleX: number;
	scaleY: number;
	scene: Scene;
	spectatorScale: number;
	dependencyScale: number;
	isVisible: boolean;
	getCurrentScale(type: number): void;
	onSkinChange(): void;
	setScale(type: number, scale: number): void;
	tweenScale(options: TweenScaleOptions): void;
	update(): void;
}
export interface Shadow {
	character: Character;
	image?: GameObjects.Image;
	createShadow(): void;
	destroy(): void;
	update(): void;
}
export interface SkinOptions {
	id: string;
	editStyles?: Record<string, string>;
}
export interface SkinSetupOptions extends SkinOptions {
	x?: number;
	y?: number;
}
export interface Skin {
	character: Character;
	editStyles?: Record<string, string>;
	latestSkinId: string;
	scene: Scene;
	skinId: string;
	applyEditStyles(options: SkinOptions): void;
	setupSkin(position: SkinSetupOptions): void;
	updateSkin(options: SkinOptions): void;
}
export interface TintParams {
	type: string;
	fromColor: string;
	toColor: string;
	duration: number;
	tween?: Tweens.Tween;
	ease(t: number): number;
}
export interface Tint {
	character: Character;
	scene: Scene;
	phase?: TintParams;
	playerAppearanceModifierDevice?: TintParams;
	immunity?: TintParams;
	damageBoost?: TintParams;
	getTintParams(type: string): TintParams | undefined;
	setTintParams(type: string, tint?: TintParams): void;
	startAnimateTint(params: TintParams): void;
	stopAnimateTint(type: string): void;
	update(): void;
}
export interface VFX {
	character: Character;
	damageBoostActive: boolean;
	phaseActive: boolean;
	tintModifierId: string;
	transparencyModifierId: string;
	setTintModifier(id: string): void;
	setTransparencyModifier(id: string): void;
	startDamageBoostAnim(): void;
	startPhaseAnim(): void;
	stopDamageBoostAnim(): void;
	stopPhaseAnim(): void;
}
export interface Character {
	aimingAndLookingAround: AimingAndLookingAround;
	alpha: Alpha;
	animation: CharacterAnimation;
	body: Vector;
	characterTrail: CharacterTrail;
	culling: Culling;
	depth: Depth;
	dimensions: Dimensions;
	flip: Flip;
	healthbar: Healthbar;
	id: string;
	immunity: Immunity;
	impactAnimation: ImpactAnimation;
	indicator: Indicator;
	input: CharacterInput;
	isActive: boolean;
	isDestroyed: boolean;
	isMain: boolean;
	movement: Movement;
	nametag: Nametag;
	network: Network;
	physics: Physics;
	position: CharacterPosition;
	prevBody: Vector;
	scale: Scale;
	scene: Scene;
	shadow: Shadow;
	skin: Skin;
	spine: any;
	teamId: string;
	tint: Tint;
	type: string;
	vfx: VFX;
	destroy(): void;
	setIsMain(isMain: boolean): void;
	update(dt: number): void;
}
export interface ActivityFeed {
	feedItems: {
		id: string;
		message: string;
	}[];
}
export interface Assignment {
	hasSavedProgress: boolean;
	objective: string;
	percentageComplete: number;
}
export interface EditingStore {
	accessPoints: Map<string, {
		name: string;
		position: Vector;
	}>;
	gridSnap: number;
	showMemoryBarAtAllTimes: boolean;
}
export interface Hooks {
	hookJSON: string;
}
export interface Loading {
	completedInitialLoad: boolean;
	loadedInitialDevices: boolean;
	loadedInitialTerrain: boolean;
	percentageAssetsLoaded: number;
}
export interface Matchmaker {
	gameCode: string;
}
export interface NetworkStore {
	attemptingToConnect: boolean;
	attemptingToReconnect: boolean;
	authId: string;
	client: any;
	clientConnectionString: string;
	error: any;
	errorFindingServerForGame: boolean;
	errorJoiningRoom: boolean;
	failedToReconnect: boolean;
	findingServerForGame: boolean;
	hasJoinedRoom: boolean;
	isOffline: boolean;
	isUpToDateWithPingPong: boolean;
	joinedRoom: boolean;
	phaseBeforeReconnect: string | null;
	ping: number;
	room: any;
	roomIntentErrorMessage: string;
	syncingAfterReconnection: boolean;
}
export interface PhaserStore {
	mainCharacter: Character;
	mainCharacterTeleported: boolean;
	scene: Scene;
}
export interface SceneStore {
	currentScene: string;
	gpuTier: number;
	isCursorOverCanvas: boolean;
}
export interface Team {
	characters: Map<number, string>;
	id: string;
	name: string;
	score: number;
}
export interface Teams {
	teams: Map<string, Team>;
	updateCounter: number;
}
/** The stores type is incomplete and is not guaranteed to be accurate */
export interface Stores {
	activityFeed: ActivityFeed;
	assignment: Assignment;
	characters: Characters;
	editing: EditingStore;
	gui: GUI;
	hooks: Hooks;
	loading: Loading;
	matchmaker: Matchmaker;
	me: Me;
	memorySystem: MemorySystem;
	network: NetworkStore;
	phaser: PhaserStore;
	scene: SceneStore;
	session: Session;
	teams: Teams;
	world: GimkitWorld;
	worldOptions: WorldOptions;
}
}

import { ReactElement } from 'react';

export interface BaseSetting<K extends string, T> {
	id: K;
	default?: T;
	onChange?: (value: T, remote: boolean) => void;
}
export interface NamedSetting<K extends string, T> extends BaseSetting<K, T> {
	title: string;
	description?: string;
}
export interface DropdownSetting<K extends string> extends NamedSetting<K, string> {
	type: "dropdown";
	options: {
		label: string;
		value: string;
	}[];
	allowNone?: boolean;
}
export interface MultiselectSetting<K extends string> extends NamedSetting<K, string[]> {
	type: "multiselect";
	options: {
		label: string;
		value: string;
	}[];
}
export interface NumberSetting<K extends string> extends NamedSetting<K, number> {
	type: "number";
	min?: number;
	max?: number;
	step?: number;
}
export interface ToggleSetting<K extends string> extends NamedSetting<K, boolean> {
	type: "toggle";
}
export interface TextSetting<K extends string> extends NamedSetting<K, string> {
	type: "text";
	placeholder?: string;
	maxLength?: number;
}
export interface SliderSetting<K extends string> extends NamedSetting<K, number> {
	type: "slider";
	min: number;
	max: number;
	step?: number;
	ticks?: number[];
	formatter?: (value: number) => string;
}
export interface RadioSetting<K extends string> extends NamedSetting<K, string> {
	type: "radio";
	options: {
		label: string;
		value: string;
	}[];
}
export interface ColorSetting<K extends string> extends NamedSetting<K, string> {
	type: "color";
	rgba?: boolean;
}
export interface CustomSetting<K extends string, T = any> extends NamedSetting<K, T> {
	type: "custom";
	render: (container: HTMLElement, currentValue: T, update: (newValue: T) => void) => (() => void) | void;
}
export interface CustomSection<K extends string, T = any> extends BaseSetting<K, T> {
	type: "customsection";
	render: (container: HTMLElement, currentValue: T, onChange: (newValue: T) => void) => (() => void) | void;
}
export type PluginSetting<K extends string> = DropdownSetting<K> | MultiselectSetting<K> | NumberSetting<K> | ToggleSetting<K> | TextSetting<K> | SliderSetting<K> | RadioSetting<K> | ColorSetting<K> | CustomSetting<K> | CustomSection<K>;
export interface SettingGroup {
	type: "group";
	title: string;
	settings: PluginSetting<any>[];
}
export type PluginSettingsDescription = (PluginSetting<any> | SettingGroup)[];
export type SettingsChangeCallback = (value: any, remote: boolean) => void;
export type DescriptionToReturnType<T extends PluginSetting<any>> = T extends DropdownSetting<any> ? string : T extends MultiselectSetting<any> ? string[] : T extends NumberSetting<any> ? number : T extends ToggleSetting<any> ? boolean : T extends TextSetting<any> ? string : T extends SliderSetting<any> ? number : T extends RadioSetting<any> ? string : T extends ColorSetting<any> ? string : T extends CustomSetting<any, infer V> ? V : T extends CustomSection<any, infer V> ? V : never;
export type ExtractSettingObject<T> = T extends PluginSetting<infer Id> ? {
	[K in Id]: DescriptionToReturnType<T>;
} : T extends SettingGroup ? ExtractSettingObject<T["settings"][number]> : never;
export type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;
export interface SettingsMethods {
	create<const T extends PluginSettingsDescription>(description: T): UnionToIntersection<ExtractSettingObject<T[number]>>;
	listen(key: string, callback: SettingsChangeCallback, immediate?: boolean): () => void;
}
export type PluginSettings = SettingsMethods & Record<string, any>;
/** @inline */
export interface HotkeyTrigger {
	/** Should be a keyboardevent [code](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code) */
	key?: string;
	/** Should be keyboardevent [codes](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code) */
	keys?: string[];
	ctrl?: boolean;
	shift?: boolean;
	alt?: boolean;
}
/** @inline */
export interface HotkeyOptions extends HotkeyTrigger {
	preventDefault?: boolean;
}
/** @inline */
export interface ConfigurableHotkeyOptions {
	category: string;
	/** There should be no duplicate titles within a category */
	title: string;
	preventDefault?: boolean;
	default?: HotkeyTrigger;
}
export interface OldConfigurableOptions {
	category: string;
	title: string;
	preventDefault?: boolean;
	defaultKeys?: Set<string>;
}
/** @inline */
export type KeyboardCallback = (e: KeyboardEvent) => void;
class BaseHotkeysApi {
	/**
	 * Releases all keys, needed if a hotkey opens something that will
	 * prevent keyup events from being registered, such as an alert
	 */
	releaseAll(): void;
	/** Which key codes are currently being pressed */
	get pressed(): Set<string>;
	/**
	 * @deprecated Use {@link pressed} instead
	 * @hidden
	 */
	get pressedKeys(): Set<string>;
}
class HotkeysApi extends BaseHotkeysApi {
	/**
	 * Adds a hotkey with a given id
	 * @returns A function to remove the hotkey
	 */
	addHotkey(id: string, options: HotkeyOptions, callback: KeyboardCallback): () => void;
	/** Removes all hotkeys with a given id */
	removeHotkeys(id: string): void;
	/**
	 * Adds a hotkey which can be changed by the user
	 * @param id A unique id for the hotkey, such as `myplugin-myhotkey`
	 * @returns A function to remove the hotkey
	 */
	addConfigurableHotkey(id: string, options: ConfigurableHotkeyOptions, callback: KeyboardCallback): () => void;
	/** Removes a configurable hotkey with a given id */
	removeConfigurableHotkey(id: string): void;
	/**
	 * @deprecated Use {@link addHotkey} instead
	 * @hidden
	 */
	add(keys: Set<string>, callback: KeyboardCallback, preventDefault?: boolean): void;
	/**
	 * @deprecated Use {@link removeHotkeys} instead
	 * @hidden
	 */
	remove(keys: Set<string>): void;
	/**
	 * @deprecated Use {@link addConfigurableHotkey} instead
	 * @hidden
	 */
	addConfigurable(pluginName: string, hotkeyId: string, callback: KeyboardCallback, options: OldConfigurableOptions): void;
	/**
	 * @deprecated Use {@link removeConfigurableHotkeys} instead
	 * @hidden
	 */
	removeConfigurable(pluginName: string, hotkeyId: string): void;
}
class ScopedHotkeysApi extends BaseHotkeysApi {
	#private;
	constructor(id: string);
	/**
	 * Adds a hotkey which will fire when certain keys are pressed
	 * @returns A function to remove the hotkey
	 */
	addHotkey(options: HotkeyOptions, callback: KeyboardCallback): () => void;
	/**
	 * Adds a hotkey which can be changed by the user
	 * @returns A function to remove the hotkey
	 */
	addConfigurableHotkey(options: ConfigurableHotkeyOptions, callback: KeyboardCallback): () => void;
}
class BaseParcelApi {
	/**
	 * Gets a module based on a filter, returns null if none are found
	 * Be cautious when using this- plugins will often run before any modules load in,
	 * meaning that if this is run on startup it will likely return nothing.
	 * Consider using getLazy instead.
	 */
	query(): any;
	/**
	 * Returns an array of all loaded modules matching a filter
	 * Be cautious when using this- plugins will often run before any modules load in,
	 * meaning that if this is run on startup it will likely return nothing.
	 * Consider using getLazy instead.
	 */
	queryAll(): any[];
}
class ParcelApi extends BaseParcelApi {
	/**
	 * Waits for a module to be loaded, then runs a callback
	 * @returns A function to cancel waiting for the module
	 */
	getLazy(): () => void;
	/** Cancels any calls to getLazy with the same id */
	stopLazy(): void;
	/**
	 * @deprecated Use {@link getLazy} instead
	 * @hidden
	 */
	get interceptRequire(): () => () => void;
	/**
	 * @deprecated Use {@link stopLazy} instead
	 * @hidden
	 */
	get stopIntercepts(): () => void;
}
class ScopedParcelApi extends BaseParcelApi {
	/**
	 * Waits for a module to be loaded, then runs a callback
	 * @returns A function to cancel waiting for the module
	 */
	getLazy(): () => void;
}
type event$1 = (symbol | string);
export type eventNS = string | event$1[];
export interface ConstructorOptions {
	/**
	 * @default false
	 * @description set this to `true` to use wildcards.
	 */
	wildcard?: boolean;
	/**
	 * @default '.'
	 * @description the delimiter used to segment namespaces.
	 */
	delimiter?: string;
	/**
	 * @default false
	 * @description set this to `true` if you want to emit the newListener events.
	 */
	newListener?: boolean;
	/**
	 * @default false
	 * @description set this to `true` if you want to emit the removeListener events.
	 */
	removeListener?: boolean;
	/**
	 * @default 10
	 * @description the maximum amount of listeners that can be assigned to an event.
	 */
	maxListeners?: number;
	/**
	 * @default false
	 * @description show event name in memory leak message when more than maximum amount of listeners is assigned, default false
	 */
	verboseMemoryLeak?: boolean;
	/**
	 * @default false
	 * @description disable throwing uncaughtException if an error event is emitted and it has no listeners
	 */
	ignoreErrors?: boolean;
}
export interface ListenerFn {
	(...values: any[]): void;
}
export interface EventAndListener {
	(event: string | string[], ...values: any[]): void;
}
export interface WaitForFilter {
	(...values: any[]): boolean;
}
export interface WaitForOptions {
	/**
	 * @default 0
	 */
	timeout: number;
	/**
	 * @default null
	 */
	filter: WaitForFilter;
	/**
	 * @default false
	 */
	handleError: boolean;
	/**
	 * @default Promise
	 */
	Promise: Function;
	/**
	 * @default false
	 */
	overload: boolean;
}
export interface CancelablePromise<T> extends Promise<T> {
	cancel(reason: string): undefined;
}
export interface OnceOptions {
	/**
	 * @default 0
	 */
	timeout: number;
	/**
	 * @default Promise
	 */
	Promise: Function;
	/**
	 * @default false
	 */
	overload: boolean;
}
export interface ListenToOptions {
	on?: {
		(event: event$1 | eventNS, handler: ListenerFn): void;
	};
	off?: {
		(event: event$1 | eventNS, handler: ListenerFn): void;
	};
	reducers: Function | Object;
}
export interface GeneralEventEmitter {
	addEventListener(event: event$1, handler: ListenerFn): this;
	removeEventListener(event: event$1, handler: ListenerFn): this;
	addListener?(event: event$1, handler: ListenerFn): this;
	removeListener?(event: event$1, handler: ListenerFn): this;
	on?(event: event$1, handler: ListenerFn): this;
	off?(event: event$1, handler: ListenerFn): this;
}
export interface OnOptions {
	async?: boolean;
	promisify?: boolean;
	nextTick?: boolean;
	objectify?: boolean;
}
export interface Listener {
	emitter: EventEmitter2;
	event: event$1 | eventNS;
	listener: ListenerFn;
	off(): this;
}
class EventEmitter2 {
	constructor(options?: ConstructorOptions);
	emit(event: event$1 | eventNS, ...values: any[]): boolean;
	emitAsync(event: event$1 | eventNS, ...values: any[]): Promise<any[]>;
	addListener(event: event$1 | eventNS, listener: ListenerFn): this | Listener;
	on(event: event$1 | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
	prependListener(event: event$1 | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
	once(event: event$1 | eventNS, listener: ListenerFn, options?: true | OnOptions): this | Listener;
	prependOnceListener(event: event$1 | eventNS, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
	many(event: event$1 | eventNS, timesToListen: number, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
	prependMany(event: event$1 | eventNS, timesToListen: number, listener: ListenerFn, options?: boolean | OnOptions): this | Listener;
	onAny(listener: EventAndListener): this;
	prependAny(listener: EventAndListener): this;
	offAny(listener: ListenerFn): this;
	removeListener(event: event$1 | eventNS, listener: ListenerFn): this;
	off(event: event$1 | eventNS, listener: ListenerFn): this;
	removeAllListeners(event?: event$1 | eventNS): this;
	setMaxListeners(n: number): void;
	getMaxListeners(): number;
	eventNames(nsAsArray?: boolean): (event$1 | eventNS)[];
	listenerCount(event?: event$1 | eventNS): number;
	listeners(event?: event$1 | eventNS): ListenerFn[];
	listenersAny(): ListenerFn[];
	waitFor(event: event$1 | eventNS, timeout?: number): CancelablePromise<any[]>;
	waitFor(event: event$1 | eventNS, filter?: WaitForFilter): CancelablePromise<any[]>;
	waitFor(event: event$1 | eventNS, options?: WaitForOptions): CancelablePromise<any[]>;
	listenTo(target: GeneralEventEmitter, events: event$1 | eventNS, options?: ListenToOptions): this;
	listenTo(target: GeneralEventEmitter, events: event$1[], options?: ListenToOptions): this;
	listenTo(target: GeneralEventEmitter, events: Object, options?: ListenToOptions): this;
	stopListeningTo(target?: GeneralEventEmitter, event?: event$1 | eventNS): Boolean;
	hasListeners(event?: String): Boolean;
	static once(emitter: EventEmitter2, event: event$1 | eventNS, options?: OnceOptions): CancelablePromise<any[]>;
	static defaultMaxListeners: number;
}
export type ConnectionType = "None" | "Colyseus" | "Blueboat";
export interface RequesterOptions {
	url: string;
	method?: string;
	data?: any;
	cacheKey?: string;
	success?: (response: any, cached: boolean) => void;
	both?: () => void;
	error?: (error: any) => void;
}
class BaseNetApi extends EventEmitter2 {
	constructor();
	/** Which type of server the client is currently connected to */
	get type(): ConnectionType;
	/** The id of the gamemode the player is currently playing */
	get gamemode(): string;
	/** The room that the client is connected to, or null if there is no connection */
	get room(): any;
	/** Whether the user is the one hosting the current game */
	get isHost(): boolean;
	/** Sends a message to the server on a specific channel */
	send(channel: string, message?: any): void;
}
class NetApi extends BaseNetApi {
	constructor();
	/**
	 * Runs a callback when the game is loaded, or runs it immediately if the game has already loaded
	 * @returns A function to cancel waiting for load
	 */
	onLoad(id: string, callback: (type: ConnectionType, gamemode: string) => void, gamemode?: string | string[]): () => void;
	/** Cancels any calls to {@link onLoad} with the same id */
	offLoad(id: string): void;
	/** Runs a callback when a request is made that matches a certain path (can have wildcards) */
	modifyFetchRequest(id: string, path: string, callback: (options: RequesterOptions) => any): () => void;
	/** Runs a callback when a response is recieved for a request under a certain path (can have wildcards) */
	modifyFetchResponse(id: string, path: string, callback: (response: any) => any): () => void;
	/** Stops any modifications made by {@link modifyFetchRequest} with the same id */
	stopModifyRequest(id: string): void;
	/** Stops any modifications made by {@link modifyFetchResponse} with the same id */
	stopModifyResponse(id: string): void;
	/**
	 * @deprecated Methods for both transports are now on the base net api
	 * @hidden
	 */
	get colyseus(): this;
	/**
	 * @deprecated Methods for both transports are now on the base net api
	 * @hidden
	 */
	get blueboat(): this;
	/** @hidden */
	private wrappedListeners;
	/**
	 * @deprecated use net.on
	 * @hidden
	 */
	addEventListener(channel: string, callback: (...args: any[]) => void): void;
	/**
	 * @deprecated use net.off
	 * @hidden
	 */
	removeEventListener(channel: string, callback: (...args: any[]) => void): void;
}
class ScopedNetApi extends BaseNetApi {
	#private;
	constructor(id: string, defaultGamemode: string[]);
	/**
	 * Runs a callback when the game is loaded, or runs it immediately if the game has already loaded.
	 * If the \@gamemode header is set the callback will only fire if the gamemode matches one of the provided gamemodes.
	 * @returns A function to cancel waiting for load
	 */
	onLoad(callback: (type: ConnectionType, gamemode: string) => void, gamemode?: string | string[]): () => void;
	/** Runs a callback when a request is made that matches a certain path (can have wildcards) */
	modifyFetchRequest(path: string, callback: (options: RequesterOptions) => any): () => void;
	/** Runs a callback when a response is recieved for a request under a certain path (can have wildcards) */
	modifyFetchResponse(path: string, callback: (response: any) => any): () => void;
}
export interface ModalButton {
	text: string;
	style?: "primary" | "danger" | "close";
	onClick?: (event: MouseEvent) => boolean | void;
}
/** @inline */
export interface ModalOptions {
	id?: string;
	title?: string;
	style?: string;
	className?: string;
	closeOnBackgroundClick?: boolean;
	buttons?: ModalButton[];
	onClosed?: () => void;
}
export type NoticeType = "info" | "success" | "error" | "warning" | "loading";
export type MessageSemanticClassNames = {
	root?: string;
	icon?: string;
	content?: string;
};
export type MessageSemanticStyles = {
	root?: React$1.CSSProperties;
	icon?: React$1.CSSProperties;
	content?: React$1.CSSProperties;
};
export type ArgsClassNamesType = MessageSemanticClassNames;
export type ArgsStylesType = MessageSemanticStyles;
export interface MessageConfigOptions {
	top?: string | number;
	duration?: number;
	prefixCls?: string;
	getContainer?: () => HTMLElement;
	transitionName?: string;
	maxCount?: number;
	rtl?: boolean;
	pauseOnHover?: boolean;
	classNames?: ArgsClassNamesType;
	styles?: ArgsStylesType;
}
export interface MessageArgsProps {
	content: React$1.ReactNode;
	duration?: number;
	type?: NoticeType;
	onClose?: () => void;
	icon?: React$1.ReactNode;
	key?: string | number;
	style?: React$1.CSSProperties;
	className?: string;
	classNames?: ArgsClassNamesType;
	styles?: ArgsStylesType;
	onClick?: (e: React$1.MouseEvent<HTMLDivElement>) => void;
	pauseOnHover?: boolean;
}
export type MessageJointContent = React$1.ReactNode | MessageArgsProps;
export interface MessageType extends PromiseLike<boolean> {
	(): void;
}
export type MessageTypeOpen = (content: MessageJointContent, duration?: number | VoidFunction, onClose?: VoidFunction) => MessageType;
export interface MessageInstance {
	info: MessageTypeOpen;
	success: MessageTypeOpen;
	error: MessageTypeOpen;
	warning: MessageTypeOpen;
	loading: MessageTypeOpen;
	open: (args: MessageArgsProps) => MessageType;
	destroy: (key?: React$1.Key) => void;
}
export interface MessageBaseMethods {
	open: (config: MessageArgsProps) => MessageType;
	destroy: (key?: React$1.Key) => void;
	config: (config: MessageConfigOptions) => void;
	useMessage: () => MessageInstance;
	_InternalPanelDoNotUseOrYouWillBeFired: React$1.FC<any>;
}
export interface MessageMethods {
	info: MessageTypeOpen;
	success: MessageTypeOpen;
	error: MessageTypeOpen;
	warning: MessageTypeOpen;
	loading: MessageTypeOpen;
}
const NotificationPlacements: readonly [
	"top",
	"topLeft",
	"topRight",
	"bottom",
	"bottomLeft",
	"bottomRight"
];
export type NotificationPlacement = (typeof NotificationPlacements)[number];
export type NotificationIconType = "success" | "info" | "error" | "warning";
export type NotificationSemanticClassNames = {
	root?: string;
	title?: string;
	description?: string;
	actions?: string;
	icon?: string;
};
export type NotificationSemanticStyles = {
	root?: React$1.CSSProperties;
	title?: React$1.CSSProperties;
	description?: React$1.CSSProperties;
	actions?: React$1.CSSProperties;
	icon?: React$1.CSSProperties;
};
export type NotificationClassNamesType = NotificationSemanticClassNames;
export type NotificationStylesType = NotificationSemanticStyles;
export interface NotificationDivProps extends React$1.HTMLProps<HTMLDivElement> {
	"data-testid"?: string;
}
export interface NotificationArgsProps {
	message?: React$1.ReactNode;
	title?: React$1.ReactNode;
	description?: React$1.ReactNode;
	btn?: React$1.ReactNode;
	actions?: React$1.ReactNode;
	key?: React$1.Key;
	onClose?: () => void;
	duration?: number | false;
	showProgress?: boolean;
	pauseOnHover?: boolean;
	icon?: React$1.ReactNode;
	placement?: NotificationPlacement;
	style?: React$1.CSSProperties;
	className?: string;
	classNames?: NotificationClassNamesType;
	styles?: NotificationStylesType;
	readonly type?: NotificationIconType;
	onClick?: () => void;
	closeIcon?: React$1.ReactNode;
	closable?: boolean | {
		onClose?: () => void;
	};
	props?: NotificationDivProps;
	role?: "alert" | "status";
}
export type NotificationStaticFn = (args: NotificationArgsProps) => void;
export interface NotificationInstance {
	success: NotificationStaticFn;
	error: NotificationStaticFn;
	info: NotificationStaticFn;
	warning: NotificationStaticFn;
	open: NotificationStaticFn;
	destroy: (key?: React$1.Key) => void;
}
export interface NotificationGlobalConfigProps {
	top?: number;
	bottom?: number;
	duration?: number | false;
	showProgress?: boolean;
	pauseOnHover?: boolean;
	prefixCls?: string;
	getContainer?: () => HTMLElement | ShadowRoot;
	placement?: NotificationPlacement;
	closeIcon?: React$1.ReactNode;
	closable?: boolean | {
		onClose?: () => void;
	};
	rtl?: boolean;
	maxCount?: number;
	props?: NotificationDivProps;
}
export interface NotificationBaseMethods {
	open: (config: NotificationArgsProps) => void;
	destroy: (key?: React$1.Key) => void;
	config: (config: NotificationGlobalConfigProps) => void;
	useNotification: () => NotificationInstance;
	_InternalPanelDoNotUseOrYouWillBeFired: React$1.FC<any>;
}
export interface NotificationNoticeMethods {
	success: NotificationStaticFn;
	info: NotificationStaticFn;
	warning: NotificationStaticFn;
	error: NotificationStaticFn;
}
export type ModalSemanticClassNames = {
	root?: string;
	header?: string;
	body?: string;
	footer?: string;
	container?: string;
	title?: string;
	wrapper?: string;
	mask?: string;
};
export type ModalSemanticStyles = {
	root?: React$1.CSSProperties;
	header?: React$1.CSSProperties;
	body?: React$1.CSSProperties;
	footer?: React$1.CSSProperties;
	container?: React$1.CSSProperties;
	title?: React$1.CSSProperties;
	wrapper?: React$1.CSSProperties;
	mask?: React$1.CSSProperties;
};
export type ModalClassNamesType = ModalSemanticClassNames;
export type ModalStylesType = ModalSemanticStyles;
export type ModalMousePosition = {
	x: number;
	y: number;
} | null;
export type ModalGetContainerFunc = () => HTMLElement;
export type ModalLegacyButtonType = "primary" | "dashed" | "default" | "text" | "link";
export interface ModalCommonProps {
	footer?: React$1.ReactNode | ((originNode: React$1.ReactNode, extra: {
		OkBtn: React$1.FC;
		CancelBtn: React$1.FC;
	}) => React$1.ReactNode);
	closable?: boolean | {
		onClose?: () => void;
		afterClose?: () => void;
	};
	classNames?: ModalClassNamesType;
	styles?: ModalStylesType;
}
export interface ModalProps extends ModalCommonProps {
	open?: boolean;
	confirmLoading?: boolean;
	title?: React$1.ReactNode;
	onOk?: (e: React$1.MouseEvent<HTMLButtonElement>) => void;
	onCancel?: (e: React$1.MouseEvent<HTMLButtonElement>) => void;
	afterClose?: () => void;
	afterOpenChange?: (open: boolean) => void;
	centered?: boolean;
	width?: string | number;
	okText?: React$1.ReactNode;
	okType?: ModalLegacyButtonType;
	cancelText?: React$1.ReactNode;
	maskClosable?: boolean;
	forceRender?: boolean;
	okButtonProps?: Record<string, any>;
	cancelButtonProps?: Record<string, any>;
	destroyOnClose?: boolean;
	destroyOnHidden?: boolean;
	style?: React$1.CSSProperties;
	wrapClassName?: string;
	maskTransitionName?: string;
	transitionName?: string;
	className?: string;
	rootClassName?: string;
	rootStyle?: React$1.CSSProperties;
	getContainer?: string | HTMLElement | ModalGetContainerFunc | false;
	zIndex?: number;
	bodyStyle?: React$1.CSSProperties;
	maskStyle?: React$1.CSSProperties;
	mask?: boolean | "static";
	keyboard?: boolean;
	wrapProps?: any;
	prefixCls?: string;
	closeIcon?: React$1.ReactNode;
	modalRender?: (node: React$1.ReactNode) => React$1.ReactNode;
	children?: React$1.ReactNode;
	mousePosition?: ModalMousePosition;
	loading?: boolean;
	focusTriggerAfterClose?: boolean;
	focusable?: {
		focusTriggerAfterClose?: boolean;
	};
}
export interface ModalFuncProps extends ModalCommonProps {
	prefixCls?: string;
	className?: string;
	rootClassName?: string;
	open?: boolean;
	title?: React$1.ReactNode;
	content?: React$1.ReactNode;
	onOk?: (...args: any[]) => any;
	onCancel?: (...args: any[]) => any;
	afterClose?: () => void;
	okButtonProps?: Record<string, any>;
	cancelButtonProps?: Record<string, any>;
	centered?: boolean;
	width?: string | number;
	okText?: React$1.ReactNode;
	okType?: ModalLegacyButtonType;
	cancelText?: React$1.ReactNode;
	icon?: React$1.ReactNode;
	mask?: boolean | "static";
	maskClosable?: boolean;
	zIndex?: number;
	okCancel?: boolean;
	style?: React$1.CSSProperties;
	wrapClassName?: string;
	maskStyle?: React$1.CSSProperties;
	type?: "info" | "success" | "error" | "warn" | "warning" | "confirm";
	keyboard?: boolean;
	getContainer?: string | HTMLElement | ModalGetContainerFunc | false;
	transitionName?: string;
	maskTransitionName?: string;
	direction?: "ltr" | "rtl";
	bodyStyle?: React$1.CSSProperties;
	closeIcon?: React$1.ReactNode;
	footer?: ModalProps["footer"];
	modalRender?: (node: React$1.ReactNode) => React$1.ReactNode;
	focusTriggerAfterClose?: boolean;
	autoFocusButton?: null | "ok" | "cancel";
	focusable?: {
		focusTriggerAfterClose?: boolean;
		autoFocusButton?: null | "ok" | "cancel";
	};
}
export type ModalConfigUpdate = ModalFuncProps | ((prevConfig: ModalFuncProps) => ModalFuncProps);
export interface ModalFuncReturn {
	destroy: () => void;
	update: (configUpdate: ModalConfigUpdate) => void;
}
export type ModalFunc = (props: ModalFuncProps) => ModalFuncReturn;
export interface ModalStaticFunctions {
	info: ModalFunc;
	success: ModalFunc;
	error: ModalFunc;
	warning: ModalFunc;
	confirm: ModalFunc;
	warn: ModalFunc;
}
export interface ModalBaseMethods {
	useModal: () => [
		api: any,
		contextHolder: React$1.ReactNode
	];
	destroyAll: () => void;
	config: (config: {
		rootPrefixCls: string;
	}) => void;
	_InternalPanelDoNotUseOrYouWillBeFired: React$1.FC<any>;
}
export type AntdNotification = NotificationNoticeMethods & NotificationBaseMethods;
export type AntdMessage = MessageMethods & MessageBaseMethods;
export type AntdModal = React$1.FC<ModalProps> & ModalStaticFunctions & ModalBaseMethods;
class BaseUIApi {
	/** Shows a customizable modal to the user */
	showModal(element: HTMLElement | React$1.ReactElement, options?: ModalOptions): void;
	/**
	 * Gimkit's notification object, only available when joining or playing a game
	 *
	 * {@link https://ant.design/components/notification#api}
	 */
	get notification(): AntdNotification;
	/**
	 * Gimkit's message object
	 *
	 * {@link https://ant.design/components/message#api}
	 */
	get message(): AntdMessage;
	/**
	 * Gimkit's modal object
	 *
	 * {@link https://ant.design/components/modal#modalmethod}
	 */
	get modal(): AntdModal;
}
class UIApi extends BaseUIApi {
	/**
	 * Adds a style to the DOM
	 * @returns A function to remove the styles
	 */
	addStyles(id: string, style: string): () => void;
	/** Remove all styles with a given id */
	removeStyles(id: string): void;
}
class ScopedUIApi extends BaseUIApi {
	#private;
	constructor(id: string);
	/**
	 * Adds a style to the DOM
	 * @returns A function to remove the styles
	 */
	addStyles(style: string): () => void;
}
/** @inline */
export type ValueChangeCallback = (value: any, remote: boolean) => void;
class StorageApi {
	/** Gets a value that has previously been saved */
	getValue(pluginName: string, key: string, defaultValue?: any): any;
	/** Sets a value which can be retrieved later, through reloads */
	setValue(pluginName: string, key: string, value: any): void;
	/** Removes a value which has been saved */
	deleteValue(pluginName: string, key: string): void;
	/**
	 * @deprecated use {@link deleteValue}
	 * @hidden
	 */
	get removeValue(): (pluginName: string, key: string) => void;
	/** Adds a listener for when a plugin's stored value with a certain key changes */
	onChange(pluginName: string, key: string, callback: ValueChangeCallback): () => void;
	/** Removes a listener added by onChange */
	offChange(pluginName: string, key: string, callback: ValueChangeCallback): void;
	/** Removes all listeners added by onChange for a certain plugin */
	offAllChanges(pluginName: string): void;
}
class ScopedStorageApi {
	#private;
	constructor(id: string);
	/** Gets a value that has previously been saved */
	getValue(key: string, defaultValue?: any): any;
	/** Sets a value which can be retrieved later, persisting through reloads */
	setValue(key: string, value: any): void;
	/** Removes a value which has been saved */
	deleteValue(key: string): void;
	/** Adds a listener for when a stored value with a certain key changes  */
	onChange(key: string, callback: ValueChangeCallback): () => void;
}
/** @inline */
export type PatcherAfterCallback = (thisVal: any, args: IArguments, returnVal: any) => any;
/** @inline */
export type PatcherBeforeCallback = (thisVal: any, args: IArguments) => boolean | void;
/** @inline */
export type PatcherInsteadCallback = (thisVal: any, args: IArguments) => void;
class PatcherApi {
	/**
	 * Runs a callback after a function on an object has been run
	 * @returns A function to remove the patch
	 */
	after(id: string, object: any, method: string, callback: PatcherAfterCallback): () => void;
	/**
	 * Runs a callback before a function on an object has been run.
	 * Return true from the callback to prevent the function from running
	 * @returns A function to remove the patch
	 */
	before(id: string, object: any, method: string, callback: PatcherBeforeCallback): () => void;
	/**
	 * Runs a function instead of a function on an object
	 * @returns A function to remove the patch
	 */
	instead(id: string, object: any, method: string, callback: PatcherInsteadCallback): () => void;
	/** Removes all patches with a given id */
	unpatchAll(id: string): void;
}
class ScopedPatcherApi {
	#private;
	constructor(id: string);
	/**
	 * Runs a callback after a function on an object has been run
	 * @returns A function to remove the patch
	 */
	after(object: any, method: string, callback: PatcherAfterCallback): () => void;
	/**
	 * Runs a callback before a function on an object has been run.
	 * Return true from the callback to prevent the function from running
	 * @returns A function to remove the patch
	 */
	before(object: any, method: string, callback: PatcherBeforeCallback): () => void;
	/**
	 * Runs a function instead of a function on an object
	 * @returns A function to remove the patch
	 */
	instead(object: any, method: string, callback: PatcherInsteadCallback): () => void;
}
/** @inline */
export type RunInScopeCallback = (code: string, run: (evalCode: string) => void) => true | void;
/** @inline */
export interface Exposer {
	check?: string;
	find: RegExp;
	callback: (val: any) => void;
	multiple?: boolean;
}
class RewriterApi {
	/**
	 * Creates a hook that will modify the code of a script before it is run.
	 * This value is cached, so this hook may not run on subsequent page loads.
	 * addParseHook should always be called in the top level of a script.
	 * @param pluginName The name of the plugin creating the hook.
	 * @param prefix Limits the hook to only running on scripts beginning with this prefix.
	 * Passing `true` will only run on the index script, and passing `false` will run on all scripts.
	 * @param modifier A function that will modify the code, which should return the modified code.
	 */
	addParseHook(pluginName: string, prefix: string | boolean, modifier: (code: string) => string): () => void;
	/** Removes all parse hooks created by a certain plugin */
	removeParseHooks(pluginName: string): void;
	/**
	 * Creates a shared value that can be accessed from any script.
	 * @param pluginName The name of the plugin creating the shared value.
	 * @param id A unique identifier for the shared value.
	 * @param value The value to be shared.
	 * @returns A string representing the code to access the shared value.
	 */
	createShared(pluginName: string, id: string, value: any): string;
	/** Removes all values created by {@link createShared} by a certain plugin */
	removeShared(pluginName: string): void;
	/** Removes the shared value with a certain id created by {@link createShared} */
	removeSharedById(pluginName: string, id: string): void;
	/**
	 * Runs code in the scope of modules when they are loaded, or when runInScope is called with them already loaded.
	 * Returning true from the callback will remove the hook.
	 */
	runInScope(pluginName: string, prefix: string | boolean, callback: RunInScopeCallback): () => void;
	/** Stops all hooks created by {@link runInScope} */
	removeRunInScope(pluginName: string): void;
	/** A utility function that exposes a variable based on regex to get its name. */
	exposeVar(pluginName: string, prefix: string | boolean, exposer: Exposer): () => void;
}
class ScopedRewriterApi {
	#private;
	constructor(id: string);
	/**
	 * Creates a hook that will modify the code of a script before it is run.
	 * This value is cached, so this hook may not run on subsequent page loads.
	 * addParseHook should always be called in the top level of a script.
	 * @param prefix Limits the hook to only running on scripts beginning with this prefix.
	 * Passing `true` will only run on the index script, and passing `false` will run on all scripts.
	 * @param modifier A function that will modify the code, which should return the modified code.
	 */
	addParseHook(prefix: string | boolean, modifier: (code: string) => string): () => void;
	/**
	 * Creates a shared value that can be accessed from any script.
	 * @param id A unique identifier for the shared value.
	 * @param value The value to be shared.
	 * @returns A string representing the code to access the shared value.
	 */
	createShared(id: string, value: any): string;
	/** Removes the shared value with a certain id created by {@link createShared} */
	removeSharedById(id: string): void;
	/**
	 * Runs code in the scope of modules when they are loaded, or when runInScope is called with them already loaded.
	 * Returning true from the callback will remove the hook.
	 */
	runInScope(prefix: string | boolean, callback: RunInScopeCallback): () => void;
	/** A utility function that exposes a variable based on regex to get its name. */
	exposeVar(prefix: string | boolean, exposer: Exposer): () => void;
}
/** @inline */
export interface CommandOptions {
	text: string | (() => string);
	keywords?: string[];
	hidden?: () => boolean;
}
export interface BaseCommandOptions {
	title: string;
}
export interface CommandSelectOptions extends BaseCommandOptions {
	options: {
		label: string;
		value: string;
	}[];
}
export interface CommandNumberOptions extends BaseCommandOptions {
	min?: number;
	max?: number;
	decimal?: boolean;
}
export interface CommandStringOptions extends BaseCommandOptions {
	maxLength?: number;
}
/** @inline */
export interface CommandContext {
	select(options: CommandSelectOptions): Promise<string>;
	number(options: CommandNumberOptions): Promise<number>;
	string(options: CommandStringOptions): Promise<string>;
}
/** @inline */
export type CommandCallback = (context: CommandContext) => void | Promise<void>;
class CommandsApi {
	/** Adds a command to the user's command palette. Can request additional input within the callback. */
	addCommand(id: string, options: CommandOptions, callback: CommandCallback): () => void;
	/** Removes all commands that were added with the same id */
	removeCommands(id: string): void;
}
class ScopedCommandsApi {
	#private;
	constructor(id: string);
	/** Adds a command to the user's command palette. Can request additional input within the callback. */
	addCommand(options: CommandOptions, callback: CommandCallback): () => void;
}
export interface ScriptHeaders {
	name: string;
	description: string;
	author: string;
	version: string | null;
	reloadRequired: string;
	isLibrary: string;
	downloadUrl: string | null;
	webpage: string | null;
	needsLib: string[];
	optionalLib: string[];
	deprecated: string | null;
	gamemode: string[];
	changelog: string[];
	/** Only available for plugins */
	needsPlugin: string[];
	hasSettings: string;
}
class LibsApi {
	/** A list of all the libraries installed */
	get list(): string[];
	/** Gets whether or not a plugin is installed and enabled */
	isEnabled(name: string): boolean;
	/** Gets the headers of a library, such as version, author, and description */
	getHeaders(name: string): ScriptHeaders;
	/** Gets the exported values of a library */
	get<T extends keyof Gimloader.Libraries>(name: T): Gimloader.Libraries[T];
}
class PluginsApi {
	/** A list of all the plugins installed */
	get list(): string[];
	/** Whether a plugin exists and is enabled */
	isEnabled(name: string): boolean;
	/** Gets the headers of a plugin, such as version, author, and description */
	getHeaders(name: string): ScriptHeaders;
	/** Gets the exported values of a plugin, if it has been enabled */
	get<T extends keyof Gimloader.Plugins>(name: T): Gimloader.Plugins[T];
	/**
	 * @deprecated Use {@link get} instead
	 * @hidden
	 */
	getPlugin(name: string): {
		return: any;
	};
}
class Api {
	#private;
	/**
	 * @deprecated Gimkit has switched from Parcel to vite, rendering this api useless.
	 * @hidden
	 */
	static parcel: Readonly<ParcelApi>;
	/** Functions to edit Gimkit's code */
	static rewriter: Readonly<RewriterApi>;
	/** Functions to listen for key combinations */
	static hotkeys: Readonly<HotkeysApi>;
	/**
	 * Ways to interact with the current connection to the server,
	 * and functions to send general requests
	 */
	static net: Readonly<NetApi>;
	/** Functions for interacting with the DOM */
	static UI: Readonly<UIApi>;
	/** Functions for persisting data between reloads */
	static storage: Readonly<StorageApi>;
	/** Functions for intercepting the arguments and return values of functions */
	static patcher: Readonly<PatcherApi>;
	/** Functions for adding commands to the command palette */
	static commands: Readonly<CommandsApi>;
	/** Methods for getting info on libraries */
	static libs: Readonly<LibsApi>;
	/** Gets the exported values of a library */
	static lib: <T extends keyof Gimloader.Libraries>(name: T) => Gimloader.Libraries[T];
	/** Methods for getting info on plugins */
	static plugins: Readonly<PluginsApi>;
	/** Gets the exported values of a plugin, if it has been enabled */
	static plugin: <T extends keyof Gimloader.Plugins>(name: T) => Gimloader.Plugins[T];
	/** Gimkit's internal react instance */
	static get React(): typeof import("react");
	/** Gimkit's internal reactDom instance */
	static get ReactDOM(): typeof import("react-dom/client");
	/** A variety of Gimkit internal objects available in 2d gamemodes */
	static get stores(): Stores.Stores;
	/**
	 * @deprecated Use GL.UI.notification
	 * @hidden
	 */
	static get notification(): AntdNotification;
	/**
	 * @deprecated No longer supported
	 * @hidden
	 */
	static get contextMenu(): {
		showContextMenu: () => void;
		createReactContextMenu: () => void;
	};
	/**
	 * @deprecated No longer supported
	 * @hidden
	 */
	static get platformerPhysics(): any;
	/**
	 * @deprecated The api no longer emits events. Use GL.net.loaded to listen to load events
	 * @hidden
	 */
	static addEventListener(type: string, callback: () => void): void;
	/**
	 * @deprecated The api no longer emits events
	 * @hidden
	 */
	static removeEventListener(type: string, callback: () => void): void;
	/**
	 * @deprecated Use {@link plugins} instead
	 * @hidden
	 */
	static get pluginManager(): Readonly<PluginsApi>;
	constructor(type?: string, name?: string);
	/**
	 * @deprecated Gimkit has switched from Parcel to vite, rendering this api useless.
	 * @hidden
	 */
	parcel: Readonly<ScopedParcelApi>;
	/** Functions to edit Gimkit's code */
	rewriter: Readonly<ScopedRewriterApi>;
	/** Functions to listen for key combinations */
	hotkeys: Readonly<ScopedHotkeysApi>;
	/**
	 * Ways to interact with the current connection to the server,
	 * and functions to send general requests
	 */
	net: Readonly<ScopedNetApi>;
	/** Functions for interacting with the DOM */
	UI: Readonly<ScopedUIApi>;
	/** Functions for persisting data between reloads */
	storage: Readonly<ScopedStorageApi>;
	/** Functions for intercepting the arguments and return values of functions */
	patcher: Readonly<ScopedPatcherApi>;
	/** Functions for adding commands to the command palette */
	commands: Readonly<ScopedCommandsApi>;
	/** A utility for creating persistent settings menus, only available to plugins */
	settings: PluginSettings;
	/** Methods for getting info on libraries */
	libs: Readonly<LibsApi>;
	/** Gets the exported values of a library */
	lib: <T extends keyof Gimloader.Libraries>(name: T) => Gimloader.Libraries[T];
	/** Methods for getting info on plugins */
	plugins: Readonly<PluginsApi>;
	/** Gets the exported values of a plugin, if it has been enabled */
	plugin: <T extends keyof Gimloader.Plugins>(name: T) => Gimloader.Plugins[T];
	/** Gimkit's internal react instance */
	get React(): typeof import("react");
	/** Gimkit's internal reactDom instance */
	get ReactDOM(): typeof import("react-dom/client");
	/** A variety of gimkit internal objects available in 2d gamemodes */
	get stores(): Stores.Stores;
	/**
	 * @deprecated Use api.UI.notification
	 * @hidden
	 */
	get notification(): AntdNotification;
	/** Run a callback when the script is disabled */
	onStop: (callback: () => void) => void;
	/**
	 * Run a callback when the plugin's settings menu button is clicked
	 *
	 * This function is not available for libraries
	 */
	openSettingsMenu: (callback: () => void) => void;
	/** Display a modal to the user indicating that the script requires a reload */
	requestReload: () => void;
}

interface Plugins {
    [name: string]: any;
}

interface Libraries {
    [name: string]: any;
}
}
const api: Gimloader.Api;
const GL: typeof Gimloader.Api;
/** @deprecated Use GL.stores */
const stores: Gimloader.Stores.Stores;
/** @deprecated No longer supported */
const platformerPhysics: any;

interface Window {
    api: Gimloader.Api;
    GL: typeof Gimloader.Api;
    /** @deprecated Use GL.stores */
    stores: Gimloader.Stores.Stores;
    /** @deprecated No longer supported */
    platformerPhysics: any;
}
}
