declare module "eventemitter2" {
export type event = (symbol|string);
export type eventNS = string|event[];

export interface ConstructorOptions {
    /**
     * @default false
     * @description set this to `true` to use wildcards.
     */
    wildcard?: boolean,
    /**
     * @default '.'
     * @description the delimiter used to segment namespaces.
     */
    delimiter?: string,
    /**
     * @default false
     * @description set this to `true` if you want to emit the newListener events.
     */
    newListener?: boolean,
    /**
     * @default false
     * @description set this to `true` if you want to emit the removeListener events.
     */
    removeListener?: boolean,
    /**
     * @default 10
     * @description the maximum amount of listeners that can be assigned to an event.
     */
    maxListeners?: number
    /**
     * @default false
     * @description show event name in memory leak message when more than maximum amount of listeners is assigned, default false
     */
    verboseMemoryLeak?: boolean
    /**
     * @default false
     * @description disable throwing uncaughtException if an error event is emitted and it has no listeners
     */
    ignoreErrors?: boolean
}
export interface ListenerFn {
    (...values: any[]): void;
}
export interface EventAndListener {
    (event: string | string[], ...values: any[]): void;
}

export interface WaitForFilter { (...values: any[]): boolean }

export interface WaitForOptions {
    /**
     * @default 0
     */
    timeout: number,
    /**
     * @default null
     */
    filter: WaitForFilter,
    /**
     * @default false
     */
    handleError: boolean,
    /**
     * @default Promise
     */
    Promise: Function,
    /**
     * @default false
     */
    overload: boolean
}

export interface CancelablePromise<T> extends Promise<T>{
    cancel(reason: string): undefined
}

export interface OnceOptions {
    /**
     * @default 0
     */
    timeout: number,
    /**
     * @default Promise
     */
    Promise: Function,
    /**
     * @default false
     */
    overload: boolean
}

export interface ListenToOptions {
    on?: { (event: event | eventNS, handler: ListenerFn): void },
    off?: { (event: event | eventNS, handler: ListenerFn): void },
    reducers: Function | Object
}

export interface GeneralEventEmitter{
    addEventListener(event: event, handler: ListenerFn): this,
    removeEventListener(event: event, handler: ListenerFn): this,
    addListener?(event: event, handler: ListenerFn): this,
    removeListener?(event: event, handler: ListenerFn): this,
    on?(event: event, handler: ListenerFn): this,
    off?(event: event, handler: ListenerFn): this
}

export interface OnOptions {
    async?: boolean,
    promisify?: boolean,
    nextTick?: boolean,
    objectify?: boolean
}

export interface Listener {
    emitter: EventEmitter2;
    event: event|eventNS;
    listener: ListenerFn;
    off(): this;
}

export declare class EventEmitter2 {
    constructor(options?: ConstructorOptions)
    emit(event: event | eventNS, ...values: any[]): boolean;
    emitAsync(event: event | eventNS, ...values: any[]): Promise<any[]>;
    addListener(event: event | eventNS, listener: ListenerFn): this|Listener;
    on(event: event | eventNS, listener: ListenerFn, options?: boolean|OnOptions): this|Listener;
    prependListener(event: event | eventNS, listener: ListenerFn, options?: boolean|OnOptions): this|Listener;
    once(event: event | eventNS, listener: ListenerFn, options?: true|OnOptions): this|Listener;
    prependOnceListener(event: event | eventNS, listener: ListenerFn, options?: boolean|OnOptions): this|Listener;
    many(event: event | eventNS, timesToListen: number, listener: ListenerFn, options?: boolean|OnOptions): this|Listener;
    prependMany(event: event | eventNS, timesToListen: number, listener: ListenerFn, options?: boolean|OnOptions): this|Listener;
    onAny(listener: EventAndListener): this;
    prependAny(listener: EventAndListener): this;
    offAny(listener: ListenerFn): this;
    removeListener(event: event | eventNS, listener: ListenerFn): this;
    off(event: event | eventNS, listener: ListenerFn): this;
    removeAllListeners(event?: event | eventNS): this;
    setMaxListeners(n: number): void;
    getMaxListeners(): number;
    eventNames(nsAsArray?: boolean): (event|eventNS)[];
    listenerCount(event?: event | eventNS): number
    listeners(event?: event | eventNS): ListenerFn[]
    listenersAny(): ListenerFn[]
    waitFor(event: event | eventNS, timeout?: number): CancelablePromise<any[]>
    waitFor(event: event | eventNS, filter?: WaitForFilter): CancelablePromise<any[]>
    waitFor(event: event | eventNS, options?: WaitForOptions): CancelablePromise<any[]>
    listenTo(target: GeneralEventEmitter, events: event | eventNS, options?: ListenToOptions): this;
    listenTo(target: GeneralEventEmitter, events: event[], options?: ListenToOptions): this;
    listenTo(target: GeneralEventEmitter, events: Object, options?: ListenToOptions): this;
    stopListeningTo(target?: GeneralEventEmitter, event?: event | eventNS): Boolean;
    hasListeners(event?: String): Boolean
    static once(emitter: EventEmitter2, event: event | eventNS, options?: OnceOptions): CancelablePromise<any[]>;
    static defaultMaxListeners: number;
}

export default EventEmitter2;

}
declare module "types/hotkeys" {
    /** @inline */
    export interface HotkeyTrigger {
        /** Should be a keyboardevent [code](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code) */
        key?: string;
        /** Should be keyboardevent [codes](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code) */
        keys?: string[];
        ctrl?: boolean;
        shift?: boolean;
        alt?: boolean;
    }
    /** @inline */
    export interface HotkeyOptions extends HotkeyTrigger {
        preventDefault?: boolean;
    }
    /** @inline */
    export interface ConfigurableHotkeyOptions {
        category: string;
        /** There should be no duplicate titles within a category */
        title: string;
        preventDefault?: boolean;
        default?: HotkeyTrigger;
    }
}
declare module "types/state" {
    import type { HotkeyTrigger } from "types/hotkeys";
    export interface PluginInfo {
        script: string;
        name: string;
        enabled: boolean;
    }
    export interface LibraryInfo {
        script: string;
        name: string;
    }
    export type ScriptInfo = PluginInfo | LibraryInfo;
    export type PluginStorage = Record<string, Record<string, any>>;
    export type ConfigurableHotkeysState = Record<string, HotkeyTrigger | null>;
    export interface Settings {
        pollerEnabled: boolean;
        autoUpdate: boolean;
        autoDownloadMissingLibs: boolean;
        menuView: 'grid' | 'list';
        showPluginButtons: boolean;
    }
    export interface SavedState {
        plugins: PluginInfo[];
        libraries: LibraryInfo[];
        pluginStorage: PluginStorage;
        settings: Settings;
        hotkeys: ConfigurableHotkeysState;
        cacheInvalid: boolean;
    }
    export interface State extends SavedState {
        availableUpdates: string[];
    }
}
declare module "content/core/storage.svelte" {
    import type { PluginStorage, Settings } from "types/state";
    /** @inline */
    export type ValueChangeCallback = (value: any, remote: boolean) => void;
    interface ValueChangeListener {
        id: string;
        key: string;
        callback: ValueChangeCallback;
    }
    const _default_3: {
        settings: Settings;
        values: PluginStorage;
        updateListeners: ValueChangeListener[];
        init(values: PluginStorage, settings: Settings): void;
        updateState(values: PluginStorage, settings: Settings): void;
        updateSetting(key: string, value: any, emit?: boolean): void;
        getPluginValue(id: string, key: string, defaultVal?: any): any;
        setPluginValue(id: string, key: string, value: any, emit?: boolean): void;
        deletePluginValue(id: string, key: string, emit?: boolean): void;
        deletePluginValues(id: string, emit?: boolean): void;
        onPluginValueUpdate(id: string, key: string, callback: ValueChangeCallback): () => void;
        offPluginValueUpdate(id: string, key: string, callback: ValueChangeCallback): void;
        removeUpdateListeners(id: string): void;
        emit(event: import("eventemitter2").event | import("eventemitter2").eventNS, ...values: any[]): boolean;
        emitAsync(event: import("eventemitter2").event | import("eventemitter2").eventNS, ...values: any[]): Promise<any[]>;
        addListener(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn): import("eventemitter2").Listener | /*elided*/ any;
        on(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        prependListener(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        once(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn, options?: true | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        prependOnceListener(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        many(event: import("eventemitter2").event | import("eventemitter2").eventNS, timesToListen: number, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        prependMany(event: import("eventemitter2").event | import("eventemitter2").eventNS, timesToListen: number, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        onAny(listener: import("eventemitter2").EventAndListener): /*elided*/ any;
        prependAny(listener: import("eventemitter2").EventAndListener): /*elided*/ any;
        offAny(listener: import("eventemitter2").ListenerFn): /*elided*/ any;
        removeListener(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn): /*elided*/ any;
        off(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn): /*elided*/ any;
        removeAllListeners(event?: import("eventemitter2").event | import("eventemitter2").eventNS): /*elided*/ any;
        setMaxListeners(n: number): void;
        getMaxListeners(): number;
        eventNames(nsAsArray?: boolean): (import("eventemitter2").event | import("eventemitter2").eventNS)[];
        listenerCount(event?: import("eventemitter2").event | import("eventemitter2").eventNS): number;
        listeners(event?: import("eventemitter2").event | import("eventemitter2").eventNS): import("eventemitter2").ListenerFn[];
        listenersAny(): import("eventemitter2").ListenerFn[];
        waitFor(event: import("eventemitter2").event | import("eventemitter2").eventNS, timeout?: number): import("eventemitter2").CancelablePromise<any[]>;
        waitFor(event: import("eventemitter2").event | import("eventemitter2").eventNS, filter?: import("eventemitter2").WaitForFilter): import("eventemitter2").CancelablePromise<any[]>;
        waitFor(event: import("eventemitter2").event | import("eventemitter2").eventNS, options?: import("eventemitter2").WaitForOptions): import("eventemitter2").CancelablePromise<any[]>;
        listenTo(target: import("eventemitter2").GeneralEventEmitter, events: import("eventemitter2").event | import("eventemitter2").eventNS, options?: import("eventemitter2").ListenToOptions): /*elided*/ any;
        listenTo(target: import("eventemitter2").GeneralEventEmitter, events: import("eventemitter2").event[], options?: import("eventemitter2").ListenToOptions): /*elided*/ any;
        listenTo(target: import("eventemitter2").GeneralEventEmitter, events: Object, options?: import("eventemitter2").ListenToOptions): /*elided*/ any;
        stopListeningTo(target?: import("eventemitter2").GeneralEventEmitter, event?: import("eventemitter2").event | import("eventemitter2").eventNS): Boolean;
        hasListeners(event?: String): Boolean;
    };
    export default _default_3;
}
declare module "content/core/patcher" {
    /** @inline */
    export type PatcherAfterCallback = (thisVal: any, args: IArguments, returnVal: any) => any;
    /** @inline */
    export type PatcherBeforeCallback = (thisVal: any, args: IArguments) => boolean | void;
    /** @inline */
    export type PatcherInsteadCallback = (thisVal: any, args: IArguments) => void;
    type Patch = {
        callback: PatcherBeforeCallback;
        point: 'before';
    } | {
        callback: PatcherAfterCallback;
        point: 'after';
    } | {
        callback: PatcherInsteadCallback;
        point: 'instead';
    };
    export default class Patcher {
        static patches: Map<object, Map<string, {
            original: any;
            patches: Patch[];
        }>>;
        static unpatchers: Map<string, (() => void)[]>;
        static applyPatches(object: object, property: string): void;
        static addPatch(object: object, property: string, patch: Patch): void;
        static getRemovePatch(id: string | null, object: object, property: string, patch: Patch): () => void;
        static after(id: string | null, object: object, property: string, callback: PatcherAfterCallback): () => void;
        static before(id: string | null, object: object, property: string, callback: PatcherBeforeCallback): () => void;
        static instead(id: string | null, object: object, property: string, callback: PatcherInsteadCallback): () => void;
        static unpatchAll(id: string): void;
    }
}
declare module "content/core/net/net" {
    interface BlueboatConnection {
        type: "Blueboat";
        room: any;
    }
    interface ColyseusConnection {
        type: "Colyseus";
        room: any;
    }
    interface NoConnection {
        type: "None";
        room: null;
    }
    export type Connection = BlueboatConnection | ColyseusConnection | NoConnection;
    interface LoadCallback {
        callback: (type: Connection["type"]) => void;
        id: string;
    }
    const _default_5: {
        type: Connection["type"];
        room: Connection["room"];
        loaded: boolean;
        loadCallbacks: LoadCallback[];
        init(): void;
        onColyseusRoom(room: any): void;
        onBlueboatRoom(room: any): void;
        waitForColyseusLoad(): void;
        send(channel: string, message: any): void;
        downloadLibrary(url: string): Promise<void>;
        onLoad(type: Connection["type"]): void;
        pluginOnLoad(id: string, callback: (type: Connection["type"]) => void): () => void;
        pluginOffLoad(id: string): void;
        readonly isHost: boolean;
        emit(event: import("eventemitter2").event | import("eventemitter2").eventNS, ...values: any[]): boolean;
        emitAsync(event: import("eventemitter2").event | import("eventemitter2").eventNS, ...values: any[]): Promise<any[]>;
        addListener(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn): import("eventemitter2").Listener | /*elided*/ any;
        on(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        prependListener(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        once(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn, options?: true | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        prependOnceListener(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        many(event: import("eventemitter2").event | import("eventemitter2").eventNS, timesToListen: number, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        prependMany(event: import("eventemitter2").event | import("eventemitter2").eventNS, timesToListen: number, listener: import("eventemitter2").ListenerFn, options?: boolean | import("eventemitter2").OnOptions): import("eventemitter2").Listener | /*elided*/ any;
        onAny(listener: import("eventemitter2").EventAndListener): /*elided*/ any;
        prependAny(listener: import("eventemitter2").EventAndListener): /*elided*/ any;
        offAny(listener: import("eventemitter2").ListenerFn): /*elided*/ any;
        removeListener(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn): /*elided*/ any;
        off(event: import("eventemitter2").event | import("eventemitter2").eventNS, listener: import("eventemitter2").ListenerFn): /*elided*/ any;
        removeAllListeners(event?: import("eventemitter2").event | import("eventemitter2").eventNS): /*elided*/ any;
        setMaxListeners(n: number): void;
        getMaxListeners(): number;
        eventNames(nsAsArray?: boolean): (import("eventemitter2").event | import("eventemitter2").eventNS)[];
        listenerCount(event?: import("eventemitter2").event | import("eventemitter2").eventNS): number;
        listeners(event?: import("eventemitter2").event | import("eventemitter2").eventNS): import("eventemitter2").ListenerFn[];
        listenersAny(): import("eventemitter2").ListenerFn[];
        waitFor(event: import("eventemitter2").event | import("eventemitter2").eventNS, timeout?: number): import("eventemitter2").CancelablePromise<any[]>;
        waitFor(event: import("eventemitter2").event | import("eventemitter2").eventNS, filter?: import("eventemitter2").WaitForFilter): import("eventemitter2").CancelablePromise<any[]>;
        waitFor(event: import("eventemitter2").event | import("eventemitter2").eventNS, options?: import("eventemitter2").WaitForOptions): import("eventemitter2").CancelablePromise<any[]>;
        listenTo(target: import("eventemitter2").GeneralEventEmitter, events: import("eventemitter2").event | import("eventemitter2").eventNS, options?: import("eventemitter2").ListenToOptions): /*elided*/ any;
        listenTo(target: import("eventemitter2").GeneralEventEmitter, events: import("eventemitter2").event[], options?: import("eventemitter2").ListenToOptions): /*elided*/ any;
        listenTo(target: import("eventemitter2").GeneralEventEmitter, events: Object, options?: import("eventemitter2").ListenToOptions): /*elided*/ any;
        stopListeningTo(target?: import("eventemitter2").GeneralEventEmitter, event?: import("eventemitter2").event | import("eventemitter2").eventNS): Boolean;
        hasListeners(event?: String): Boolean;
    };
    export default _default_5;
}
declare module "content/api/hotkeys" {
    import type { HotkeyOptions, ConfigurableHotkeyOptions } from "types/hotkeys";
    interface OldConfigurableOptions {
        category: string;
        title: string;
        preventDefault?: boolean;
        defaultKeys?: Set<string>;
    }
    /** @inline */
    type KeyboardCallback = (e: KeyboardEvent) => void;
    class BaseHotkeysApi {
        /**
         * Releases all keys, needed if a hotkey opens something that will
         * prevent keyup events from being registered, such as an alert
         */
        releaseAll(): void;
        /** Which key codes are currently being pressed */
        get pressed(): Set<string>;
        /**
         * @deprecated Use {@link pressed} instead
         * @hidden
         */
        get pressedKeys(): Set<string>;
    }
    class HotkeysApi extends BaseHotkeysApi {
        /**
         * Adds a hotkey with a given id
         * @returns A function to remove the hotkey
         */
        addHotkey(id: string, options: HotkeyOptions, callback: KeyboardCallback): () => void;
        /** Removes all hotkeys with a given id */
        removeHotkeys(id: string): void;
        /**
         * Adds a hotkey which can be changed by the user
         * @param id A unique id for the hotkey, such as `myplugin-myhotkey`
         * @returns A function to remove the hotkey
         */
        addConfigurableHotkey(id: string, options: ConfigurableHotkeyOptions, callback: KeyboardCallback): () => void;
        /** Removes a configurable hotkey with a given id */
        removeConfigurableHotkey(id: string): void;
        /**
         * @deprecated Use {@link addHotkey} instead
         * @hidden
         */
        add(keys: Set<string>, callback: KeyboardCallback, preventDefault?: boolean): void;
        /**
         * @deprecated Use {@link removeHotkeys} instead
         * @hidden
         */
        remove(keys: Set<string>): void;
        /**
         * @deprecated Use {@link addConfigurableHotkey} instead
         * @hidden
         */
        addConfigurable(pluginName: string, hotkeyId: string, callback: KeyboardCallback, options: OldConfigurableOptions): void;
        /**
         * @deprecated Use {@link removeConfigurableHotkeys} instead
         * @hidden
         */
        removeConfigurable(pluginName: string, hotkeyId: string): void;
    }
    class ScopedHotkeysApi extends BaseHotkeysApi {
        private readonly id;
        constructor(id: string);
        /**
         * Adds a hotkey which will fire when certain keys are pressed
         * @returns A function to remove the hotkey
         */
        addHotkey(options: HotkeyOptions, callback: KeyboardCallback): () => void;
        /**
         * Adds a hotkey which can be changed by the user
         * @returns A function to remove the hotkey
         */
        addConfigurableHotkey(options: ConfigurableHotkeyOptions, callback: KeyboardCallback): () => void;
    }
    export { HotkeysApi, ScopedHotkeysApi };
}
declare module "content/api/parcel" {
    class BaseParcelApi {
        /**
         * Gets a module based on a filter, returns null if none are found
         * Be cautious when using this- plugins will often run before any modules load in,
         * meaning that if this is run on startup it will likely return nothing.
         * Consider using getLazy instead.
         */
        query(): any;
        /**
         * Returns an array of all loaded modules matching a filter
         * Be cautious when using this- plugins will often run before any modules load in,
         * meaning that if this is run on startup it will likely return nothing.
         * Consider using getLazy instead.
         */
        queryAll(): any[];
    }
    class ParcelApi extends BaseParcelApi {
        /**
         * Waits for a module to be loaded, then runs a callback
         * @returns A function to cancel waiting for the module
         */
        getLazy(): () => void;
        /** Cancels any calls to getLazy with the same id */
        stopLazy(): void;
        /**
         * @deprecated Use {@link getLazy} instead
         * @hidden
         */
        get interceptRequire(): () => () => void;
        /**
         * @deprecated Use {@link stopLazy} instead
         * @hidden
         */
        get stopIntercepts(): () => void;
    }
    class ScopedParcelApi extends BaseParcelApi {
        private readonly id;
        constructor(id: string);
        /**
         * Waits for a module to be loaded, then runs a callback
         * @returns A function to cancel waiting for the module
         */
        getLazy(): () => void;
    }
    export { ParcelApi, ScopedParcelApi };
}
declare module "content/api/net" {
    import type { Connection } from "content/core/net/net";
    import EventEmitter from "eventemitter2";
    class BaseNetApi extends EventEmitter {
        constructor();
        /** Which type of server the client is currently connected to */
        get type(): Connection["type"];
        /** The room that the client is connected to, or null if there is no connection */
        get room(): Connection["room"];
        /** Whether the user is the one hosting the current game */
        get isHost(): boolean;
        /** Sends a message to the server on a specific channel */
        send(channel: string, message: any): void;
    }
    /**
     * The net api extends [EventEmitter2](https://github.com/EventEmitter2/EventEmitter2)
     * and uses wildcards with ":" as a delimiter.
     *
     * The following events are emitted:
     *
     * ```ts
     * // fired when data is recieved on a certain channel
     * net.on(CHANNEL, (data, editFn) => {})
     *
     * // fired when data is sent on a certain channel
     * net.on(send:CHANNEL, (data, editFn) => {})
     *
     * // fired when the game loads with a certain type
     * net.on(load:TYPE, (type) => {})
     *
     * // you can also use wildcards, eg
     * net.on("send:*", () => {})
     * ```
     */
    class NetApi extends BaseNetApi {
        constructor();
        /**
         * Runs a callback when the game is loaded, or runs it immediately if the game has already loaded
         * @returns A function to cancel waiting for load
         */
        onLoad(id: string, callback: (type: Connection["type"]) => void): () => void;
        /** Cancels any calls to {@link onLoad} with the same id */
        offLoad(id: string): void;
        /**
         * @deprecated Methods for both transports are now on the base net api
         * @hidden
         */
        get colyseus(): this;
        /**
         * @deprecated Methods for both transports are now on the base net api
         * @hidden
         */
        get blueboat(): this;
        /** @hidden */
        private wrappedListeners;
        /**
         * @deprecated use net.on
         * @hidden
         */
        addEventListener(channel: string, callback: (...args: any[]) => void): void;
        /**
         * @deprecated use net.off
         * @hidden
         */
        removeEventListener(channel: string, callback: (...args: any[]) => void): void;
    }
    /**
     * The net api extends [EventEmitter2](https://github.com/EventEmitter2/EventEmitter2)
     * and uses wildcards with ":" as a delimiter.
     *
     * The following events are emitted:
     *
     * ```ts
     * // fired when data is recieved on a certain channel
     * net.on(CHANNEL, (data, editFn) => {})
     *
     * // fired when data is sent on a certain channel
     * net.on(send:CHANNEL, (data, editFn) => {})
     *
     * // fired when the game loads with a certain type
     * net.on(load:TYPE, (type) => {})
     *
     * // you can also use wildcards, eg
     * net.on("send:*", () => {})
     * ```
     */
    class ScopedNetApi extends BaseNetApi {
        private readonly id;
        constructor(id: string);
        /**
         * Runs a callback when the game is loaded, or runs it immediately if the game has already loaded
         * @returns A function to cancel waiting for load
         */
        onLoad(callback: (type: Connection["type"]) => void): () => void;
    }
    export { NetApi, ScopedNetApi };
}
declare module "content/core/ui/modal" {
    import type { ReactElement } from "react";
    interface ModalButton {
        text: string;
        style?: "primary" | "danger" | "close";
        onClick?: (event: MouseEvent) => boolean | void;
    }
    /** @inline */
    export interface ModalOptions {
        id: string;
        title: string;
        style: string;
        className: string;
        closeOnBackgroundClick: boolean;
        buttons: ModalButton[];
        onClosed: () => void;
    }
    export default function showModal(content: HTMLElement | ReactElement, options?: Partial<ModalOptions>): () => void;
}
declare module "content/api/ui" {
    import type { ModalOptions } from "content/core/ui/modal";
    import type { ReactElement } from "react";
    class BaseUIApi {
        /** Shows a customizable modal to the user */
        showModal(element: HTMLElement | ReactElement, options?: Partial<ModalOptions>): void;
    }
    class UIApi extends BaseUIApi {
        /**
         * Adds a style to the DOM
         * @returns A function to remove the styles
         */
        addStyles(id: string, style: string): () => void;
        /** Remove all styles with a given id */
        removeStyles(id: string): void;
    }
    class ScopedUIApi extends BaseUIApi {
        private readonly id;
        constructor(id: string);
        /**
         * Adds a style to the DOM
         * @returns A function to remove the styles
         */
        addStyles(style: string): () => void;
    }
    export { UIApi, ScopedUIApi };
}
declare module "content/api/storage" {
    import { type ValueChangeCallback } from "content/core/storage.svelte";
    class StorageApi {
        /** Gets a value that has previously been saved */
        getValue(pluginName: string, key: string, defaultValue?: any): any;
        /** Sets a value which can be retrieved later, through reloads */
        setValue(pluginName: string, key: string, value: any): void;
        /** Removes a value which has been saved */
        deleteValue(pluginName: string, key: string): void;
        /**
         * @deprecated use {@link deleteValue}
         * @hidden
         */
        get removeValue(): (pluginName: string, key: string) => void;
        /** Adds a listener for when a plugin's stored value with a certain key changes */
        onChange(pluginName: string, key: string, callback: ValueChangeCallback): () => void;
        /** Removes a listener added by onChange */
        offChange(pluginName: string, key: string, callback: ValueChangeCallback): void;
        /** Removes all listeners added by onChange for a certain plugin */
        offAllChanges(pluginName: string): void;
    }
    class ScopedStorageApi {
        private readonly id;
        constructor(id: string);
        /** Gets a value that has previously been saved */
        getValue(key: string, defaultValue?: any): any;
        /** Sets a value which can be retrieved later, persisting through reloads */
        setValue(key: string, value: any): void;
        /** Removes a value which has been saved */
        deleteValue(key: string): void;
        /** Adds a listener for when a stored value with a certain key changes  */
        onChange(key: string, callback: ValueChangeCallback): () => void;
    }
    export { StorageApi, ScopedStorageApi };
}
declare module "content/api/patcher" {
    import type { PatcherAfterCallback, PatcherBeforeCallback, PatcherInsteadCallback } from "content/core/patcher";
    class PatcherApi {
        /**
         * Runs a callback after a function on an object has been run
         * @returns A function to remove the patch
         */
        after(id: string, object: any, method: string, callback: PatcherAfterCallback): () => void;
        /**
         * Runs a callback before a function on an object has been run.
         * Return true from the callback to prevent the function from running
         * @returns A function to remove the patch
         */
        before(id: string, object: any, method: string, callback: PatcherBeforeCallback): () => void;
        /**
         * Runs a function instead of a function on an object
         * @returns A function to remove the patch
         */
        instead(id: string, object: any, method: string, callback: PatcherInsteadCallback): () => void;
        /** Removes all patches with a given id */
        unpatchAll(id: string): void;
    }
    class ScopedPatcherApi {
        private readonly id;
        constructor(id: string);
        /**
         * Runs a callback after a function on an object has been run
         * @returns A function to remove the patch
         */
        after(object: any, method: string, callback: PatcherAfterCallback): () => void;
        /**
         * Runs a callback before a function on an object has been run.
         * Return true from the callback to prevent the function from running
         * @returns A function to remove the patch
         */
        before(object: any, method: string, callback: PatcherBeforeCallback): () => void;
        /**
         * Runs a function instead of a function on an object
         * @returns A function to remove the patch
         */
        instead(object: any, method: string, callback: PatcherInsteadCallback): () => void;
    }
    export { PatcherApi, ScopedPatcherApi };
}
declare module "content/api/rewriter" {
    /**
     * The rewriter API allows you to modify the bundled code of Gimkit in order to expose values
     * or change certain behaviors. Due to the unpredictable nature of bundling, you cannot assume that variable names
     * will remain the same beteen updates.
     * @example
     * ```js
     * const callback = GL.Rewriter.createShared("MyPlugin", "uniqueId", (val) => {
     *  console.log(val);
     * });
     *
     * GL.Rewriter.addParseHook("MyPlugin", "index", (code) => {
     *  let index = code.indexOf("something");
     *  code = code.slice(0, index) + `console.log("something else")` + code.slice(index);
     *  code += `${callback}(someVar)`;
     *  return code;
     * });
     * ```
     */
    class RewriterApi {
        /**
         * Creates a hook that will modify the code of a script before it is run.
         * This value is cached, so this hook may not run on subsequent page loads.
         * addParseHook should always be called in the top level of a script.
         * @param pluginName The name of the plugin creating the hook.
         * @param prefix Limits the hook to only running on scripts beginning with this prefix.
         * Passing `true` will only run on the index script, and passing `false` will run on all scripts.
         * @param callback The function that will modify the code. Should return the modified code. Cannot have side effects.
         */
        addParseHook(pluginName: string, prefix: string | boolean, callback: (code: string) => string): () => void;
        /** Removes all hooks created by a certain plugin */
        removeParseHooks(pluginName: string): void;
        /**
         * Creates a shared value that can be accessed from any script.
         * @param pluginName The name of the plugin creating the shared value.
         * @param id A unique identifier for the shared value.
         * @param value The value to be shared.
         * @returns A string representing the code to access the shared value.
         */
        createShared(pluginName: string, id: string, value: any): string;
        /** Removes all values created by {@link createShared} by a certain plugin */
        removeShared(pluginName: string): void;
        /** Removes the shared value with a certain id created by {@link createShared} */
        removeSharedById(pluginName: string, id: string): void;
    }
    /**
     * The rewriter API allows you to modify the bundled code of Gimkit in order to expose values
     * or change certain behaviors. Due to the unpredictable nature of bundling, you cannot assume that variable names
     * will remain the same beteen updates.
     * @example
     * ```js
     * const api = new GL();
     *
     * const callback = api.Rewriter.createShared("uniqueId", (val) => {
     *  console.log(val);
     * });
     *
     * api.Rewriter.addParseHook("index", (code) => {
     *  let index = code.indexOf("something");
     *  code = code.slice(0, index) + `console.log("something else")` + code.slice(index);
     *  code += `${callback}(someVar)`;
     *  return code;
     * });
     * ```
     */
    class ScopedRewriterApi {
        private readonly id;
        constructor(id: string);
        /**
         * Creates a hook that will modify the code of a script before it is run.
         * This value is cached, so this hook may not run on subsequent page loads.
         * addParseHook should always be called in the top level of a script.
         * @param prefix Limits the hook to only running on scripts beginning with this prefix.
         * Passing `true` will only run on the index script, and passing `false` will run on all scripts.
         * @param callback The function that will modify the code. Should return the modified code. Cannot have side effects.
         */
        addParseHook(prefix: string | boolean, callback: (code: string) => string): () => void;
        /**
         * Creates a shared value that can be accessed from any script.
         * @param id A unique identifier for the shared value.
         * @param value The value to be shared.
         * @returns A string representing the code to access the shared value.
         */
        createShared(id: string, value: any): string;
        /** Removes the shared value with a certain id created by {@link createShared} */
        removeSharedById(id: string): void;
    }
    export { RewriterApi, ScopedRewriterApi };
}
declare module "content/api/libs" {
    class LibsApi {
        /** A list of all the libraries installed */
        get list(): string[];
        /** Gets whether or not a plugin is installed and enabled */
        isEnabled(name: string): boolean;
        /** Gets the headers of a library, such as version, author, and description */
        getHeaders(name: string): {
            name: string;
            description: string;
            author: string;
            version: string | null;
            reloadRequired: string;
            isLibrary: string;
            downloadUrl: string | null;
            webpage: string | null;
            needsLib: string[];
            optionalLib: string[];
            syncEval: string;
            usesRewriter: string;
            hasSettings: string;
        };
        /** Gets the exported values of a library */
        get<T = any>(name: string): T;
    }
    export default LibsApi;
}
declare module "content/api/plugins" {
    class PluginsApi {
        /** A list of all the plugins installed */
        get list(): string[];
        /** Whether a plugin exists and is enabled */
        isEnabled(name: string): boolean;
        /** Gets the headers of a plugin, such as version, author, and description */
        getHeaders(name: string): {
            name: string;
            description: string;
            author: string;
            version: string | null;
            reloadRequired: string;
            isLibrary: string;
            downloadUrl: string | null;
            webpage: string | null;
            needsLib: string[];
            optionalLib: string[];
            syncEval: string;
            usesRewriter: string;
            hasSettings: string;
        };
        /** Gets the exported values of a plugin, if it has been enabled */
        get<T = any>(name: string): T;
        /**
         * @deprecated Use {@link get} instead
         * @hidden
         */
        getPlugin(name: string): {
            return: any;
        };
    }
    export default PluginsApi;
}
declare module "content/api/api" {
    import type { Connection } from "content/core/net/net";
    import { HotkeysApi, ScopedHotkeysApi } from "content/api/hotkeys";
    import { ParcelApi, ScopedParcelApi } from "content/api/parcel";
    import { NetApi, ScopedNetApi } from "content/api/net";
    import { UIApi, ScopedUIApi } from "content/api/ui";
    import { StorageApi, ScopedStorageApi } from "content/api/storage";
    import { PatcherApi, ScopedPatcherApi } from "content/api/patcher";
    import { RewriterApi, ScopedRewriterApi } from "content/api/rewriter";
    import LibsApi from "content/api/libs";
    import PluginsApi from "content/api/plugins";
    class Api {
        /**
         * @deprecated Gimkit has switched from Parcel to vite, rendering this api useless.
         * @hidden
         */
        static parcel: Readonly<ParcelApi>;
        /** Functions to edit Gimkit's code */
        static rewriter: Readonly<RewriterApi>;
        /** Functions to listen for key combinations */
        static hotkeys: Readonly<HotkeysApi>;
        /**
         * Ways to interact with the current connection to the server,
         * and functions to send general requests
         */
        static net: Readonly<NetApi & Connection>;
        /** Functions for interacting with the DOM */
        static UI: Readonly<UIApi>;
        /** Functions for persisting data between reloads */
        static storage: Readonly<StorageApi>;
        /** Functions for intercepting the arguments and return values of functions */
        static patcher: Readonly<PatcherApi>;
        /** Methods for getting info on libraries */
        static libs: Readonly<LibsApi>;
        /** Gets the exported values of a library */
        static lib: <T = any>(name: string) => T;
        /** Methods for getting info on plugins */
        static plugins: Readonly<PluginsApi>;
        /** Gets the exported values of a plugin, if it has been enabled */
        static plugin: <T = any>(name: string) => T;
        /** Gimkit's internal react instance */
        static get React(): typeof import("react");
        /** Gimkit's internal reactDom instance */
        static get ReactDOM(): typeof import("react-dom/client");
        /** A variety of Gimkit internal objects available in 2d gamemodes */
        static get stores(): any;
        /**
         * Gimkit's notification object, only available when joining or playing a game
         *
         * {@link https://ant.design/components/notification}
         */
        static get notification(): any;
        /**
         * @deprecated No longer supported
         * @hidden
         */
        static get contextMenu(): {
            showContextMenu: () => void;
            createReactContextMenu: () => void;
        };
        /**
         * @deprecated No longer supported
         * @hidden
         */
        static get platformerPhysics(): any;
        /**
         * @deprecated The api no longer emits events. Use GL.net.loaded to listen to load events
         * @hidden
         */
        static addEventListener(type: string, callback: () => void): void;
        /**
         * @deprecated The api no longer emits events
         * @hidden
         */
        static removeEventListener(type: string, callback: () => void): void;
        /**
         * @deprecated Use {@link plugins} instead
         * @hidden
         */
        static get pluginManager(): Readonly<PluginsApi>;
        constructor();
        /**
         * @deprecated Gimkit has switched from Parcel to vite, rendering this api useless.
         * @hidden
         */
        parcel: Readonly<ScopedParcelApi>;
        /** Functions to edit Gimkit's code */
        rewriter: Readonly<ScopedRewriterApi>;
        /** Functions to listen for key combinations */
        hotkeys: Readonly<ScopedHotkeysApi>;
        /**
         * Ways to interact with the current connection to the server,
         * and functions to send general requests
         */
        net: Readonly<ScopedNetApi & Connection>;
        /** Functions for interacting with the DOM */
        UI: Readonly<ScopedUIApi>;
        /** Functions for persisting data between reloads */
        storage: Readonly<ScopedStorageApi>;
        /** Functions for intercepting the arguments and return values of functions */
        patcher: Readonly<ScopedPatcherApi>;
        /** Methods for getting info on libraries */
        libs: Readonly<LibsApi>;
        /** Gets the exported values of a library */
        lib: <T = any>(name: string) => T;
        /** Methods for getting info on plugins */
        plugins: Readonly<PluginsApi>;
        /** Gets the exported values of a plugin, if it has been enabled */
        plugin: <T = any>(name: string) => T;
        /** Gimkit's internal react instance */
        get React(): typeof import("react");
        /** Gimkit's internal reactDom instance */
        get ReactDOM(): typeof import("react-dom/client");
        /** A variety of gimkit internal objects available in 2d gamemodes */
        get stores(): any;
        /**
         * Gimkit's notification object, only available when joining or playing a game
         *
         * {@link https://ant.design/components/notification}
         */
        get notification(): any;
        /** Run a callback when the plugin or library is disabled */
        onStop: (callback: () => void) => void;
        /**
         * Run a callback when the plugin's settings menu button is clicked
         *
         * This function is not available for libraries
         */
        openSettingsMenu: (callback: () => void) => void;
    }
    export default Api;
}

declare const GL: typeof import('content/api/api').default;
/** @deprecated Use GL.stores */
declare const stores: any;
/** @deprecated No longer supported */
declare const platformerPhysics: any;

interface Window {
    GL: typeof import('content/api/api').default;
    /** @deprecated Use GL.stores */
    stores: any;
    /** @deprecated No longer supported */
    platformerPhysics: any;
}